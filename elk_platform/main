#!/usr/bin/env python3

import asyncio
import argparse
import glob
import json
import logging
import os
import random
import requests
import subprocess
import sys
import time
import urllib

from bs4 import BeautifulSoup

try:
    from elkpy import sushicontroller as sc
    from elkpy import sushiprocessor as sp
except ImportError:
    # Not running in ELK platform, no problem as ELK-specific code won't be run
    pass

try:
    from elk_ui_custom import ElkUIController
except ModuleNotFoundError:
    pass

from source_ui import frame_from_lines, frame_from_start_animation, justify_text, add_global_message_to_frame, START_ANIMATION_DURATION, translate_cc_license_url

from flask import Flask, render_template, request, redirect, url_for, Response
from oscpy.client import OSCClient
import threading

if sys.platform == "linux" or sys.platform == "linux2":
    platform = "ELK"
else:
    platform = "desktop"

# Configure Flask logging to only show error messages
disable_flask_logging = True
if disable_flask_logging:
    log = logging.getLogger('werkzeug')
    log.setLevel(logging.ERROR)

elk_bridge_refresh_fps = 20
system_stats_refresh_fps = 1

current_frame = None
current_frame_directory = 'static/frame/' 

global_message = ('', 0, 0)  # (text, starttime, duration)

plugin_state = "No sate"
plugin_state_xml = None
time_post_state_received = None
connection_with_plugin_ok = False
old_state_seconds_threshold = 5

system_stats = {}

system_stats_thread = None
elk_bridge_thread = None

http_server = Flask(__name__, template_folder='/udata/source/app/' if platform == "ELK" else '../SourceSampler/Resources/')
osc_client = None
elk_bridge = None

SPECIAL_PAGE_NAME = "special"
parameter_pages = [
    [
        ("gain", lambda x: 12.0 * 2.0 * (x - 0.5) if x >= 0.5 else 36.0 * 2.0 * (x - 0.5), lambda x: float(x), "Gain", "{0:.2f} dB", "/set_sound_parameter"),
        ("pitch", lambda x: 36.0 * 2 * (x - 0.5), lambda x: float(x), "Pitch", "{0:.2f}", "/set_sound_parameter"),
        ("reverse", lambda x: int(round(x)), lambda x: ['Off', 'On'][int(x)], "Reverse", "{0}", "/set_sound_parameter_int"),
        ("launchMode", lambda x: int(round(4 * x)), lambda x: ['Gate', 'Loop', 'Ping-pong', 'Trigger', 'Freeze'][int(x)], "Launch mode", "{0}", "/set_sound_parameter_int"),
    ], [
        ("startPosition", lambda x: x, lambda x: float(x), "Start pos", "{0:.4f}", "/set_sound_parameter"),
        ("endPosition", lambda x: x, lambda x: float(x), "End pos", "{0:.4f}", "/set_sound_parameter"),
        ("loopStartPosition", lambda x: x, lambda x: float(x), "Loop st pos", "{0:.4f}", "/set_sound_parameter"),
        ("loopEndPosition", lambda x: x, lambda x: float(x), "Loop end pos", " {0:.4f}", "/set_sound_parameter"),
    ], [
        ("ampADSR.attack", lambda x: 20.0 * pow(x, 2), lambda x: float(x), "A", "{0:.2f}s", "/set_sound_parameter"),
        ("ampADSR.decay", lambda x: 20.0 * pow(x, 2), lambda x: float(x), "D", "{0:.2f}s", "/set_sound_parameter"),
        ("ampADSR.sustain", lambda x: x, lambda x: float(x), "S", "{0:.2f}", "/set_sound_parameter"),
        ("ampADSR.release", lambda x: 20.0 * pow(x, 2), lambda x: float(x), "R", "{0:.2f}s", "/set_sound_parameter"),
    ], [
        ("filterCutoff", lambda x: 10 + 20000 * pow(x, 2), lambda x: float(x), "Cutoff", "{0:.2f} Hz", "/set_sound_parameter"),
        ("filterRessonance", lambda x: x, lambda x: float(x), "Resso", "{0:.2f}", "/set_sound_parameter"),
        ("filterKeyboardTracking", lambda x: x, lambda x: float(x), "K.T.", "{0:.2f}", "/set_sound_parameter"),
        ("filterADSR2CutoffAmt", lambda x: 10.0 * x, lambda x: float(x), "Env amt", "{0:.2f}", "/set_sound_parameter"),
    ], [
        ("filterADSR.attack", lambda x: 20.0 * pow(x, 2), lambda x: float(x), "Filter A", "{0:.2f}s", "/set_sound_parameter"),
        ("filterADSR.decay", lambda x: 20.0 * pow(x, 2), lambda x: float(x), "Filter D", "{0:.2f}s", "/set_sound_parameter"),
        ("filterADSR.sustain", lambda x: x, lambda x: float(x), "Filter S", "{0:.2f}", "/set_sound_parameter"),
        ("filterADSR.release", lambda x: 20.0 * pow(x, 2), lambda x: float(x), "Filter R", "{0:.2f}s", "/set_sound_parameter"),
    ], [
        ("noteMappingMode", lambda x: int(round(3 * x)), lambda x: ['Pitch', 'Slice', 'Both', 'Repeat'][int(x)], "Map mode", "{0}", "/set_sound_parameter_int"),
        ("numSlices", lambda x: int(round(32.0 * x)), lambda x: (['Auto onsets', 'Auto notes']+[str(x) for x in range(2, 101)])[int(x)], "# slices", "{0}", "/set_sound_parameter_int"),
        ("playheadPosition", lambda x: x, lambda x: float(x), "Playhead", "{0:.4f}", "/set_sound_parameter"),
        ("freezePlayheadSpeed", lambda x: 1 + 4999 * pow(x, 2), lambda x: float(x), "Freeze speed", "{0:.1f}", "/set_sound_parameter"),
    ],
    SPECIAL_PAGE_NAME  # Quick hack to enable having an extra page to display sutff other than sound parameters, this should be improved...
]


# --- Utils ------------------------------------------------------------------------


def get_status_output(command):
    return os.popen(command).read()[:-1]  # Remove last char which is always \n


last_time_restarting_connman = 0


def collect_system_stats():
    global system_stats
    global last_time_restarting_connman

    if platform == "ELK":

        # Get system stats like cpu usage, temperature, etc.
        try:
            system_stats['temp'] = get_status_output("sudo vcgencmd measure_temp").replace('temp=', '').replace("'C", '')
            system_stats['cpu'] = get_status_output("grep 'cpu ' /proc/stat | awk '{usage=($2+$4)*100/($2+$4+$5)} END {print usage \"%\"}'")[0:4]
            system_stats['mem'] = get_status_output("free | grep Mem | awk '{print $3/$2 * 100.0}'")[0:4]
            proc_xenomai_output = get_status_output("more /proc/xenomai/sched/stat | grep sushi_b64")
            total_cpu = 0
            for line in proc_xenomai_output.split('\n'):
                total_cpu += float(line.split('sushi_b64')[0].strip().split(' ')[-1])
            system_stats['xenomai_cpu'] = total_cpu
            system_stats['n_sushi_proc'] = get_status_output("ps -e | grep sushi | wc -l")
            
            # Check network status and reconnect if disconnected
            connmanctl_services_output = get_status_output("sudo connmanctl services")
            network_is_connected = '*AO' in connmanctl_services_output
            if network_is_connected:
                system_stats['network_ssid'] = connmanctl_services_output.split('*AO ')[1].split(' ')[0]
                last_time_restarting_connman = 0
            else:
                system_stats['network_ssid'] = '-' + ' (R)' if last_time_restarting_connman != 0 else ''
                if time.time() - last_time_restarting_connman > 10:  # Don't try to reconnect more often than every 10 seconds
                    print('* Restarting connman')
                    last_time_restarting_connman = time.time()
                    get_status_output("sudo connmanctl enable wifi")
                    get_status_output("sudo systemctl restart connman")

            # Check aconnect status and reconnect if disconnected                    
            aconnect_l_output = get_status_output("aconnect -l")
            aconnect_is_connected = 'Connected' in aconnect_l_output
            if not aconnect_is_connected:
                print('* Running aconnect')
                out = get_status_output("aconnect 16 128")
                print(out)

        except:
            system_stats = {}


def run_collect_system_stats_loop():
    print('* Starting system stats loop')
    while True:
        time.sleep(1.0/system_stats_refresh_fps)
        collect_system_stats()


# --- ELK Bridge ------------------------------------------------------------------------

class ElkBridge(object):

    buttons_state = {}
    time_buttons_pressed = {}
    buttons_sent_note_on = {}
    selected_sound_idx = None
    current_parameter_page = 0
    starttime = 0
    ui = None
    sushi = None

    def __init__(self):

        sushi_initialized = False
        while not sushi_initialized:
            try:
                self.sushi = sc.SushiController()
                sushi_initialized = True
                print("Initialized SushiController")
            except Exception as e:
                print('ERROR initializing SushiController: {0}'.format(e))
                if platform == "ELK":
                    time.sleep(1)
                else:
                    break  # break while because this will never succeed
                

        elkui_initialized = False
        while not elkui_initialized:
            try:
                self.ui = ElkUIController(self.handle_faders,
                                          self.handle_buttons,
                                          self.handle_encoder_button,
                                          self.handle_encoder)
                elkui_initialized = True
                print("Initialized ElkUIController")
            except Exception as e:
                print('ERROR initializing ElkUIController: {0}'.format(e))
                if platform == "ELK":
                    time.sleep(1)
                else:
                    break  # break while because this will never succeed
        self.compute_display_frame(0)

    def handle_faders(self, fader_idx, val):
        shift_button_pressed = self.buttons_state.get(0, 0) == 1

        if self.selected_sound_idx is not None:
            sound_idx = self.selected_sound_idx
        else:
            sound_idx = -1
        parameter_name, send_func, _, _, _, osc_address = parameter_pages[self.current_parameter_page][fader_idx]
        send_value = send_func(val)
        if shift_button_pressed and parameter_name == "pitch" or shift_button_pressed and parameter_name == "gain":
            send_value = send_value * 0.3333333  # Reduced range mode

        osc_client.send_message(osc_address, [sound_idx, parameter_name, send_value])

    def handle_buttons(self, button_idx, val):
        stored_val = self.buttons_state.get(button_idx, 0)
        current_val = int(val)
        shift_button_pressed = self.buttons_state.get(0, 0) == 1

        if stored_val == current_val:
            # State did not change, "nothing" happened. We should not reach here...
            pass
        else:
            # Check what sound idx corresponds to the button
            sound_idx = -1
            if button_idx > 0:
                sound_idx = button_idx - 1   # from 0-7
                if shift_button_pressed:  # if "shift" button is pressed, sound index is form 8-15
                    sound_idx += 8
            
            if sound_idx > -1:
                if stored_val == 0 and current_val == 1:  # Button was pressed
                    # If sound was already selected, pressing the button again will trigger the sound
                    if self.selected_sound_idx == sound_idx:
                        osc_client.send_message("/play_sound", [sound_idx])
                        self.buttons_sent_note_on[button_idx] = True

                    # Select corresponding sound
                    self.selected_sound_idx = sound_idx
                    if self.ui is not None:
                        self.ui.set_led(button_idx, 1)  # Light corresponding LED...
                        for led_idx in range(0, 9):
                            if led_idx != button_idx:
                                self.ui.set_led(led_idx, 0)  # ...and stop the others

                elif stored_val == 1 and current_val == 0:  # Button was released
                    # If note on was triggered, trigger note off now
                    if self.buttons_sent_note_on.get(button_idx, False):
                        osc_client.send_message("/stop_sound", [sound_idx])
                        self.buttons_sent_note_on[button_idx] = False

        # Updated stored button's state
        self.time_buttons_pressed[button_idx] = time.time()
        self.buttons_state[button_idx] = current_val

    def handle_encoder_button(self, val):
        current_val = int(val)
        if current_val == 1:  # When pressed
        
            shift_button_pressed = self.buttons_state.get(0, 0) == 1

            if not shift_button_pressed:
                # If a sound is selected, unselect it
                if self.selected_sound_idx is not None:
                    self.selected_sound_idx = None
                    if self.ui is not None:
                        for led_idx in range(0, 9): 
                            self.ui.set_led(led_idx, 0)
            else:
                # Save currently loaded preset
                if plugin_state_xml is not None:
                    current_loaded_preset_name = plugin_state_xml.find_all("SourcePresetState".lower())[0].get("presetName".lower(), "Noname")
                    current_loaded_preset_index = int(plugin_state_xml.find_all("SourcePresetState".lower())[0].get("presetNumber".lower(), "-1"))
                    osc_client.send_message("/save_current_preset", [current_loaded_preset_name, current_loaded_preset_index])
                    self.show_global_message("Saving...")

    def handle_encoder(self, direction):
        shift_button_pressed = self.buttons_state.get(0, 0) == 1

        if not shift_button_pressed:
            # Cycle parameter pages
            self.current_parameter_page += direction
            if self.current_parameter_page < 0:
                self.current_parameter_page = len(parameter_pages) - 1
            elif self.current_parameter_page > len(parameter_pages) - 1:
                self.current_parameter_page = 0
        
        else:
            # Change preset
            if plugin_state_xml is not None:
                current_loaded_preset = int(plugin_state_xml.find_all("SourcePresetState".lower())[0].get("presetNumber".lower(), "-1"))
                current_loaded_preset += direction
                if current_loaded_preset < 0:
                    current_loaded_preset = 0
                osc_client.send_message("/load_preset", [current_loaded_preset])

    def run(self):

        if self.ui is not None:
            self.ui.run()

        # Start loop to call refresh for the display
        starttime = time.time()
        counter = 0
        while True:
            time.sleep(1.0/elk_bridge_refresh_fps)
            counter += 1
            time_since_start = time.time() - starttime
            if time_since_start < START_ANIMATION_DURATION:
                frame = frame_from_start_animation(time_since_start/START_ANIMATION_DURATION)
            else:
                frame = self.compute_display_frame(counter)

            # Save frame to "global_frame" var (used by simulator)
            global current_frame
            current_frame = frame

            # Send new frame to OLED display
            if self.ui is not None:
                self.ui.set_display_frame(frame)
                self.ui.refresh()

    def show_global_message(self, text, duration=2):
        global global_message
        global_message = (text, time.time(), duration)

    def compute_display_frame(self, counter):
        global connection_with_plugin_ok
        global time_post_state_received
        global plugin_state_xml
        global current_frame
        global global_message

        # Before setting new display lines, pre-compute some variables form the state

        # Check plugin connection status
        if time_post_state_received is not None and time.time() - time_post_state_received < 0.5:
            shoudl_state_received_mark = True
        else:
            shoudl_state_received_mark = None
        if time_post_state_received is not None and time.time() - time_post_state_received > old_state_seconds_threshold:
            if connection_with_plugin_ok == True:
                connection_with_plugin_ok = False
                elk_bridge.show_global_message("Pl. disconnected :(")

        # Get info to show in indicator icons
        is_querying_and_downloading = False
        if plugin_state_xml is not None:
            is_querying_and_downloading = plugin_state_xml.find_all("VolatileState".lower())[0].get('isQueryingAndDownloadingSounds'.lower(), '') != "0"       
        
        network_is_connected = '(R)' not in system_stats.get("network_ssid", "-") and system_stats.get("network_ssid", "-").lower() != 'no network'
         
        volatile_state = None
        preset_state = None
        preset_number = -1
        preset_name = "-"
        if plugin_state_xml is not None:
            volatile_state = plugin_state_xml.find_all("VolatileState".lower())[0]
            #num_active_voices = sum([int(element) for element in volatile_state.get('voiceActivations'.lower(), '').split(',') if element])
            preset_state = plugin_state_xml.find_all("SourcePresetState".lower())[0]
            preset_number = int(preset_state.get("presetNumber".lower(), "-1"))
            preset_name = preset_state.get("presetName".lower(), "no name")
        
        indicators = "{0}{1}{2}{3}".format("!" if not network_is_connected else "", "Q" if is_querying_and_downloading else "", "*" if shoudl_state_received_mark else "", ["|", "/", "-", "\\"][counter % 4])

        header_line = {
            "invert": True, 
            "text": justify_text("{0}:{1}".format(preset_number, preset_name), indicators)
        }
        display_lines = [header_line]

        # Check if a sound is selected to decide which info to show    
        if self.selected_sound_idx is not None:

            # Get properties from the selected sound
            sound_name = ""
            sound_id = 0
            sound_duration = 0
            sound_license = ""
            sound_username = ""
            sound_download_progress = 0
            params_labels_values = []
            if preset_state is not None:
                sounds_info = preset_state.find_all("soundsInfo".lower())[0].find_all("soundInfo".lower())
                if self.selected_sound_idx < len(sounds_info):
                    sound_info = sounds_info[self.selected_sound_idx]
                    sound_name = sound_info.get('soundname', '-')
                    sound_id = sound_info.get('soundid', 0)
                    sound_duration = float(sound_info.get('sounddurationinseconds', 0))
                    sound_license = translate_cc_license_url(sound_info.get('soundlicense', '-'))
                    sound_username = sound_info.get('sounduser', '-')
                    sound_download_progress = int(sound_info.get('downloadprogress', 0))

                    if parameter_pages[self.current_parameter_page] != SPECIAL_PAGE_NAME:
                        for parameter_name, _, get_func, parameter_label, value_label_template, _ in parameter_pages[self.current_parameter_page]:
                            for parameter in sound_info.find_all('samplersoundparameter'):
                                val = parameter.get('parameter_value', '')
                                if parameter.get('parameter_name', '') == parameter_name:
                                    processed_val = get_func(val)
                                    params_labels_values.append((parameter_label, value_label_template, processed_val))

            display_lines.append({
                "underline": True, 
                "text": "S{0}:{1}".format(self.selected_sound_idx, sound_name)
            })

            if parameter_pages[self.current_parameter_page] != SPECIAL_PAGE_NAME:
                # Display corresponding sound parameters
                for parameter_label, value_label_template, param_value in params_labels_values:
                    display_lines.append(justify_text(
                        parameter_label + ":", 
                        value_label_template.format(param_value)
                    ))
            else:
                # Display extra sound info
                display_lines += [
                    justify_text('ID:', '{0}'.format(sound_id)),
                    justify_text('User:', '{0}'.format(sound_username)),
                    justify_text('CC License:', '{0}'.format(sound_license)),
                    justify_text('Duration:', '{0:.2f}s'.format(sound_duration)) if sound_download_progress == 100 else justify_text('Downloading...', '{0:.1f}%'.format(sound_download_progress)),
                ]

        else:
            # Get some properties from plugin state
            num_loaded_sounds = 0
            if preset_state is not None:
                num_loaded_sounds = len(preset_state.find_all("soundsInfo".lower())[0].find_all("soundInfo".lower()))

            # Prepare parameters to show, check which parameters have been set globally because all sounds have the same
            params_labels_values = []
            if parameter_pages[self.current_parameter_page] != SPECIAL_PAGE_NAME:
                if preset_state is not None:
                    sounds_info = preset_state.find_all("soundsInfo".lower())[0].find_all("soundInfo".lower())     
                    for parameter_name, _, get_func, parameter_label, value_label_template, _ in parameter_pages[self.current_parameter_page]:
                        all_sounds_values = []
                        last_value = None
                        for sound_info in sounds_info:
                            for parameter in sound_info.find_all('samplersoundparameter'):
                                val = parameter.get('parameter_value', '')
                                if parameter.get('parameter_name', '') == parameter_name:
                                    processed_val = get_func(val)
                                    all_sounds_values.append(processed_val)
                                    last_value = processed_val
                        if len(set(all_sounds_values)) == 1:
                            # All sounds have the same value for that parameter, show the number
                            params_labels_values.append((parameter_label, value_label_template, last_value))
                        else:
                            # Some sounds differ, don't show the number
                            params_labels_values.append((parameter_label, "{0}", "-"))

            # Update lines of text for the display
            display_lines += [{
                    "underline": True,
                    "text": "{0} sounds".format(num_loaded_sounds),
                }
            ]

            if parameter_pages[self.current_parameter_page] != SPECIAL_PAGE_NAME:
                # Display corresponding sound parameters
                for parameter_label, value_label_template, param_value in params_labels_values:
                    display_lines.append(justify_text(
                        parameter_label + ":", 
                        value_label_template.format(param_value)
                    ))
            else:
                # Display extra global system info
                display_lines += [
                    justify_text('Temp:', '{0:.1f}ÂºC'.format(system_stats.get("temp", ""))),
                    justify_text('Memory:', '{0:.1f}%'.format(system_stats.get("mem", ""))),
                    justify_text('CPU:', '{0:.1f}% | {1:.1f}%'.format(system_stats.get("cpu", ""), system_stats.get("xenomai_cpu", ""))), 
                    justify_text('Network:', '{0}'.format(system_stats.get("network_ssid", "-")))
                ]
        
        # Generate new frame
        frame = frame_from_lines(display_lines)

        # If a global message should be added, do it here
        if global_message[0] != '':
            if time.time() - global_message[1] < global_message[2]:
                add_global_message_to_frame(frame, global_message[0])
            else:
                global_message = ('', 0, 0)

        return frame


def run_elk_bridge_loop():
    global elk_bridge
    print('* Starting ElkBridge')
    elk_bridge = ElkBridge()
    elk_bridge.run()


# --- Sound downloader ------------------------------------------------------------------------

class SoundDownloader:
    def __init__(self, url, outfile):
        self.old_percent = 0
        self.url = url
        self.outfile = outfile

    def download_progress_hook(self, count, blockSize, totalSize):
        percent = int(count * blockSize * 100 / totalSize)
        if percent > self.old_percent:
            self.old_percent = percent
            osc_client.send_message('/downloading_sound_progress', [self.outfile, percent])
        if percent >= 100:
            osc_client.send_message('/finished_downloading_sound', [self.outfile])


def download_sound(url, outfile):
    if not (os.path.exists(outfile) and os.path.getsize(outfile) > 0):
        # If sound does not exist, start downloading
        print('- Downloading ' + url)
        progress = SoundDownloader(url, outfile)
        urllib.request.urlretrieve(url, outfile, reporthook=progress.download_progress_hook)
    else:
        # If sound already exists, notify plugin about that
        print('- Skip downloading ' + url + ' (already downloaded)')
        osc_client.send_message('/finished_downloading_sound', [outfile])


class DownloadSoundsThread(threading.Thread):

    url = None
    outfile = None

    def __init__(self, _url, _outfile):
        super(DownloadSoundsThread, self).__init__()
        self.url = _url
        self.outfile = _outfile

    def run(self):
        asyncio.set_event_loop(asyncio.new_event_loop())
        download_sound(self.url, self.outfile)


def download_all_sounds(urls, outfiles):
    for url, outfile in zip(urls, outfiles):
        DownloadSoundsThread(url, outfile).start()


# --- HTTP Server ------------------------------------------------------------------------

@http_server.route('/', methods=['GET'])  # Serve main interface HTML file
def index_minimal():
    tvars = {}
    return render_template("index_minimal.html", **tvars)

@http_server.route('/index', methods=['GET'])  # Serve main interface HTML file
def index():
    tvars = {}
    return render_template("index.html", **tvars)

@http_server.route('/simulator', methods=['GET'])  # Serve the interface which simulates blackboard
def simulator():
    tvars = {}
    return render_template("simulator.html", **tvars)

@http_server.route('/simulator_get_display', methods=['GET'])  # Get contents of the display
def simulator_get_display():
    global current_frame
    global current_frame_directory
    files = glob.glob(os.path.join(current_frame_directory, '*'))
    for f in files:
        os.remove(f)
    path = os.path.join(current_frame_directory, 'frame{0}.jpg'.format(random.randint(0, 9999999)))
    if current_frame is not None:
        current_frame.save(path)
        return path
    else:
        return ''

@http_server.route('/simulator_user_action', methods=['GET'])  # Simulate user pressing a button, knob, etc
def simulator_user_action():
    global elk_bridge
    action = request.args['action']
    value = request.args['value']
    if action.startswith("button"):
        button_idx = int(action.split('_')[2])
        if elk_bridge is not None:
            elk_bridge.handle_buttons(button_idx, value)
    elif action.startswith("slider"):
        slider_idx = int(action.split('_')[1])
        if elk_bridge is not None:
            elk_bridge.handle_faders(slider_idx, float(value))
    elif action.startswith("encoder"):
        sub_action = action.split('_')[1]
        if sub_action == 'rotate':
            elk_bridge.handle_encoder(int(value))
        elif sub_action == 'press':
            elk_bridge.handle_encoder_button(1.0)
        elif sub_action == 'release':
            elk_bridge.handle_encoder_button(0.0)
    return 'Action received'

@http_server.route('/send_osc', methods=['GET'])  # Forwards the request contents as an OSC message to the plugin
def send_osc():
    address = request.args['address']
    values = [getattr(__builtins__, type_name)(value) for type_name, value in zip(request.args['types'].split(';'), request.args['values'].split(';'))]
    osc_client.send_message(address, values)
    
    if address == '/new_query':
        elk_bridge.show_global_message("Making query...")

    return 'OSC sent'

@http_server.route('/state_from_plugin', methods=['POST'])  # Receives a state update from the plugin and saves the contents
def state_from_plugin():
    global plugin_state
    global plugin_state_xml
    global time_post_state_received
    global connection_with_plugin_ok
    global elk_bridge
    time_post_state_received = time.time()
    plugin_state = request.data
    used_parser = "lxml"
    plugin_state_xml = BeautifulSoup(plugin_state, "lxml")
    #print('Time loading XML: {0} ({1})'.format(time.time() - time_post_state_received, used_parser))
    
    if connection_with_plugin_ok == False:
        connection_with_plugin_ok = True
        elk_bridge.show_global_message("Pl. connected :)")
    return 'State received'

@http_server.route('/update_state', methods=['GET'])  # Client requests to get an updated version of the state
def update_state():
    global connection_with_plugin_ok
    if time_post_state_received is not None and time.time() - time_post_state_received > old_state_seconds_threshold:
        if connection_with_plugin_ok == True:
            connection_with_plugin_ok = False
            elk_bridge.show_global_message("Pl. disconnected :(")
        return 'Maybe old'
    else:
        return Response(plugin_state, mimetype='text/xml')

@http_server.route('/get_system_stats', methods=['GET'])  # Return system stats
def get_system_stats():
    if system_stats:
        return "temp={0}\ncpu={1}%|{2}%\nmem={3}%\n".format(system_stats['temp'], system_stats['cpu'], system_stats['xenomai_cpu'], system_stats['mem'])
    else:
        return "No stats"

@http_server.route('/download_sounds', methods=['GET'])  # Download the sounds requested by the plugin
def download_sounds():
    urls_to_download = []
    outfiles = []
    for url in request.args['urls'].split(','):
        if url:
            sound_id = url.split('/')[-1].split('_')[0]
            outfile = os.path.join(request.args['location'], sound_id + '.ogg')
            urls_to_download.append(url)
            outfiles.append(outfile)
    download_all_sounds(urls_to_download, outfiles)
    return 'Downloading async...'


# --- Main ------------------------------------------------------------------------

class ElkBridgeThread(threading.Thread):
    def run(self):
        asyncio.set_event_loop(asyncio.new_event_loop())
        run_elk_bridge_loop()


class CollectSystemStatsThread(threading.Thread):
    def run(self):
        asyncio.set_event_loop(asyncio.new_event_loop())
        run_collect_system_stats_loop()


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--osc_ip", default="127.0.0.1", help="The IP to send OSC to")
    parser.add_argument("--osc_port", type=int, default=9001, help="The port to send OSC messages to")
    parser.add_argument("--http_port", type=int, default=8123, help="The port the web server should listen at")
    args = parser.parse_args()

    # If on ELK platform, start the thread that will do the communication with the hardware, draw on display, etc.
    if elk_bridge_refresh_fps:
        ElkBridgeThread().start()

    # Also if on ELK platform, start the thread that will collect and update system stats periodically
    if system_stats_refresh_fps:
        collect_system_stats()
        CollectSystemStatsThread().start()

    # Start OSC client to send OSC messages to plugin
    print('* Starting OSCClient')
    osc_client = OSCClient(args.osc_ip, args.osc_port, encoding='utf8')

    print('* Running aconnect')
    get_status_output("aconnect 16 128")

    # Start HTTP server that will receive state updates from the plugin and implements the web interface
    print('* Starting HTTP server at {}'.format(args.http_port))
    http_server.run(host='0.0.0.0', port=args.http_port, debug=True if platform == "desktop" else False)
