#!/usr/bin/env python3

import asyncio
import argparse
import json
import logging
import os
import requests
import subprocess
import sys
import time
import urllib

from bs4 import BeautifulSoup

try:
    from elkpy import sushicontroller as sc
    from elkpy import sushiprocessor as sp
except ImportError:
    # Not running in ELK platform, no problem as ELK-specific code won't be run
    pass

try:
    from elk_ui_custom import ElkUIController
    from elk_ui_custom import DISPLAY_LINE_LENGTH
except ModuleNotFoundError:
    # Not running in ELK platform, no problem as ELK-specific code won't be run
    DISPLAY_LINE_LENGTH = 21

from flask import Flask, render_template, request, redirect, url_for, Response
from oscpy.client import OSCClient
import threading

if sys.platform == "linux" or sys.platform == "linux2":
    platform = "ELK"
else:
    platform = "desktop"

# Configure Flask logging to only show error messages
disable_flask_logging = False
if disable_flask_logging:
    log = logging.getLogger('werkzeug')
    log.setLevel(logging.ERROR)

BUTTON_MIDI_NOTES = [48, 60, 62, 64, 65, 67, 69, 71, 72]  # C3 + C scale from C4 to C5

elk_bridge_refresh_fps = 20
system_stats_refresh_fps = 1
START_ANIMATION_N_FRAMES = 25
START_ANIMATION_LOGO_PATH = '/udata/source/app/logo_oled.png'

plugin_state = "No sate"
plugin_state_xml = None
time_post_state_received = None
connection_with_plugin_ok = False
old_state_seconds_threshold = 5

system_stats = {}

system_stats_thread = None
elk_bridge_thread = None

http_server = Flask(__name__, template_folder='/udata/source/app/' if platform == "ELK" else '../SourceSampler/Resources/')
osc_client = None
elk_bridge = None

parameter_pages = [
    [
        ("gain", lambda x: 12.0 * 2.0 * (x - 0.5), lambda x: float(x), "Gain: {0:.2f} dB", "/set_sound_parameter"),
        ("pitch", lambda x: 36.0 * 2 * (x - 0.5), lambda x: float(x), "Pitch: {0:.2f}", "/set_sound_parameter"),
        ("reverse", lambda x: int(round(x)), lambda x: ['Off', 'On'][int(x)], "Reverse: {0}", "/set_sound_parameter_int"),
        ("launchMode", lambda x: int(round(4 * x)), lambda x: ['Gate', 'Loop', 'Ping-pong', 'Trigger', 'Freeze'][int(x)], "Launch mode: {0}", "/set_sound_parameter_int"),
    ], [
        ("startPosition", lambda x: x, lambda x: float(x), "Start pos: {0:.4f}", "/set_sound_parameter"),
        ("endPosition", lambda x: x, lambda x: float(x), "End pos: {0:.4f}", "/set_sound_parameter"),
        ("loopStartPosition", lambda x: x, lambda x: float(x), "Loop st pos: {0:.4f}", "/set_sound_parameter"),
        ("loopEndPosition", lambda x: x, lambda x: float(x), "Loop end pos: {0:.4f}", "/set_sound_parameter"),
    ], [
        ("ampADSR.attack", lambda x: 20.0 * pow(x, 2), lambda x: float(x), "A: {0:.2f}s", "/set_sound_parameter"),
        ("ampADSR.decay", lambda x: 20.0 * pow(x, 2), lambda x: float(x), "D: {0:.2f}s", "/set_sound_parameter"),
        ("ampADSR.sustain", lambda x: x, lambda x: float(x), "S: {0:.2f}", "/set_sound_parameter"),
        ("ampADSR.release", lambda x: 20.0 * pow(x, 2), lambda x: float(x), "R: {0:.2f}s", "/set_sound_parameter"),
    ], [
        ("filterCutoff", lambda x: 10 + 20000 * pow(x, 2), lambda x: float(x), "Cutoff: {0:.2f} Hz", "/set_sound_parameter"),
        ("filterRessonance", lambda x: x, lambda x: float(x), "Resso: {0:.2f}", "/set_sound_parameter"),
        ("filterKeyboardTracking", lambda x: x, lambda x: float(x), "K.T.: {0:.2f}", "/set_sound_parameter"),
        ("filterADSR2CutoffAmt", lambda x: 10.0 * x, lambda x: float(x), "Env amt: {0:.2f}", "/set_sound_parameter"),
    ], [
        ("filterADSR.attack", lambda x: 20.0 * pow(x, 2), lambda x: float(x), "Filter A: {0:.2f}s", "/set_sound_parameter"),
        ("filterADSR.decay", lambda x: 20.0 * pow(x, 2), lambda x: float(x), "Filter D: {0:.2f}s", "/set_sound_parameter"),
        ("filterADSR.sustain", lambda x: x, lambda x: float(x), "Filter S: {0:.2f}", "/set_sound_parameter"),
        ("filterADSR.release", lambda x: 20.0 * pow(x, 2), lambda x: float(x), "Filter R: {0:.2f}s", "/set_sound_parameter"),
    ] , [
        ("noteMappingMode", lambda x: int(round(3 * x)), lambda x: ['Pitch', 'Slice', 'Both', 'Repeat'][int(x)], "Map mode: {0}", "/set_sound_parameter_int"),
        ("numSlices", lambda x: int(round(32.0 * x)), lambda x: (['Auto onsets', 'Auto notes']+[str(x) for x in range(2, 101)])[int(x)], "# slices: {0}", "/set_sound_parameter_int"),
        ("playheadPosition", lambda x: x, lambda x: float(x), "Playhead: {0:.4f}", "/set_sound_parameter"),
        ("freezePlayheadSpeed", lambda x: 1 + 4999 * pow(x, 2), lambda x: float(x), "Freeze speed: {0:.1f}", "/set_sound_parameter"),
    ]
]


# --- Utils ------------------------------------------------------------------------


def get_status_output(command):
    return os.popen(command).read()[:-1]  # Remove last char which is always \n


last_time_restarting_connman = 0


def collect_system_stats():
    global system_stats
    global last_time_restarting_connman

    if platform == "ELK":

        # Get system stats like cpu usage, temperature, etc.
        try:
            system_stats['temp'] = get_status_output("sudo vcgencmd measure_temp").replace('temp=', '').replace("'C", '')
            system_stats['cpu'] = get_status_output("grep 'cpu ' /proc/stat | awk '{usage=($2+$4)*100/($2+$4+$5)} END {print usage \"%\"}'")[0:4]
            system_stats['mem'] = get_status_output("free | grep Mem | awk '{print $3/$2 * 100.0}'")[0:4]
            system_stats['msw'] = "CPU  PID    MSW        CSW        XSC        PF    STAT       %CPU  NAME\n" + get_status_output("more /proc/xenomai/sched/stat | grep sushi_b64")
            system_stats['n_sushi_proc'] = get_status_output("ps -e | grep sushi | wc -l")
            
            # Check network status and reconnect if disconnected
            connmanctl_services_output = get_status_output("sudo connmanctl services")
            network_is_connected = '*AO' in connmanctl_services_output
            if network_is_connected:
                system_stats['network_ssid'] = connmanctl_services_output.split('*AO ')[1].split(' ')[0]
                last_time_restarting_connman = 0
            else:
                system_stats['network_ssid'] = '-' + ' (R)' if last_time_restarting_connman != 0 else ''
                if time.time() - last_time_restarting_connman > 10:  # Don't try to reconnect more often than every 10 seconds
                    print('* Restarting connman')
                    last_time_restarting_connman = time.time()
                    get_status_output("sudo connmanctl enable wifi")
                    get_status_output("sudo systemctl restart connman")

            # Check aconnect status and reconnect if disconnected                    
            aconnect_l_output = get_status_output("aconnect -l")
            aconnect_is_connected = 'Connected' in aconnect_l_output
            if not aconnect_is_connected:
                print('* Running aconnect')
                out = get_status_output("aconnect 16 128")
                print(out)

        except:
            system_stats = {}


def run_collect_system_stats_loop():
    print('* Starting system stats loop')
    while True:
        time.sleep(1.0/system_stats_refresh_fps)
        collect_system_stats()


# --- ELK Bridge ------------------------------------------------------------------------

class ElkBridge(object):

    buttons_state = {}
    time_buttons_pressed = {}
    buttons_sent_note_on = {}
    selected_sound_idx = None
    display_contents_for_simulator = "No contents"
    current_parameter_page = 0
    start_animation_not_finished = True
    ui = None
    sushi = None

    def __init__(self):

        sushi_initialized = False
        while not sushi_initialized:
            try:
                self.sushi = sc.SushiController()
                sushi_initialized = True
                print("Initialized SushiController")
            except Exception as e:
                print('ERROR initializing SushiController: {0}'.format(e))
                if platform == "ELK":
                    time.sleep(1)
                else:
                    break  # break while because this will never succeed
                

        elkui_initialized = False
        while not elkui_initialized:
            try:
                self.ui = ElkUIController(self.handle_faders,
                                          self.handle_buttons,
                                          self.handle_encoder_button,
                                          self.handle_encoder,
                                          start_animation_text="           SOURCE, by Rita & Aurora",
                                          start_animation_n_frames=START_ANIMATION_N_FRAMES,
                                          start_animation_logo_path=START_ANIMATION_LOGO_PATH)
                elkui_initialized = True
                print("Initialized ElkUIController")
            except Exception as e:
                print('ERROR initializing ElkUIController: {0}'.format(e))
                if platform == "ELK":
                    time.sleep(1)
                else:
                    break  # break while because this will never succeed
        self._refresh_display(0)

    def handle_faders(self, fader_idx, val):

        if self.selected_sound_idx is not None:
            parameter_name, send_func, _, _, osc_address = parameter_pages[self.current_parameter_page][fader_idx]
            osc_client.send_message(osc_address, [self.selected_sound_idx, parameter_name, send_func(val)])

    def handle_buttons(self, button_idx, val):
        stored_val = self.buttons_state.get(button_idx, 0)
        current_val = int(val)
        shift_button_pressed = self.buttons_state.get(0, 0) == 1

        if stored_val == current_val:
            # State did not change, "nothing" happened. We should not reach here...
            pass
        else:
            # Check what sound idx corresponds to the button
            sound_idx = -1
            if button_idx > 0:
                sound_idx = button_idx - 1   # from 0-7
                if shift_button_pressed:  # if "shift" button is pressed, sound index is form 8-15
                    sound_idx += 8
            
            if sound_idx > -1:
                if stored_val == 0 and current_val == 1:  # Button was pressed
                    # If sound was already selected, pressing the button again will trigger the sound
                    if self.selected_sound_idx == sound_idx:
                        #if self.buttons_sent_note_on.get(button_idx, False):  # If note on was sent without note off, stop it first (just in case)
                        #    osc_client.send_message("/stop_sound", [sound_idx])
                        osc_client.send_message("/play_sound", [sound_idx])
                        self.buttons_sent_note_on[button_idx] = True

                    # Select corresponding sound
                    self.selected_sound_idx = sound_idx
                    if self.ui is not None:
                        self.ui.set_led(button_idx, 1)  # Light corresponding LED...
                        for led_idx in range(0, 9):
                            if led_idx != button_idx:
                                self.ui.set_led(led_idx, 0)  # ...and stop the others

                elif stored_val == 1 and current_val == 0:  # Button was released
                    # If note on was triggered, trigger note off now
                    if self.buttons_sent_note_on.get(button_idx, False):
                        osc_client.send_message("/stop_sound", [sound_idx])
                        self.buttons_sent_note_on[button_idx] = False

        # Updated stored button's state
        self.time_buttons_pressed[button_idx] = time.time()
        self.buttons_state[button_idx] = current_val

    def handle_encoder_button(self, val):
        current_val = int(val)
        if current_val == 1:  # When pressed
        
            shift_button_pressed = self.buttons_state.get(0, 0) == 1

            if not shift_button_pressed:
                # If a sound is selected, unselect it
                if self.selected_sound_idx is not None:
                    self.selected_sound_idx = None
                    if self.ui is not None:
                        for led_idx in range(0, 9): 
                            self.ui.set_led(led_idx, 0)
            else:
                # Save currently loaded preset
                if plugin_state_xml is not None:
                    current_loaded_preset_name = plugin_state_xml.find_all("SourcePresetState".lower())[0].get("presetName".lower(), "Noname")
                    current_loaded_preset_index = int(plugin_state_xml.find_all("SourcePresetState".lower())[0].get("presetNumber".lower(), "-1"))
                    osc_client.send_message("/save_current_preset", [current_loaded_preset_name, current_loaded_preset_index])

    def handle_encoder(self, direction):
        
        if self.selected_sound_idx is not None:
            # If a sound is selected, cycle parameter pages
            self.current_parameter_page += direction
            if self.current_parameter_page < 0:
                self.current_parameter_page = len(parameter_pages) - 1
            elif self.current_parameter_page > len(parameter_pages) - 1:
                self.current_parameter_page = 0
        
        else:
            # If no sound is selected, change preset
            if plugin_state_xml is not None:
                current_loaded_preset = int(plugin_state_xml.find_all("SourcePresetState".lower())[0].get("presetNumber".lower(), "-1"))
                current_loaded_preset += direction
                if current_loaded_preset < 0:
                    current_loaded_preset = 0
                osc_client.send_message("/load_preset", [current_loaded_preset])

    def run(self):
        if self.ui is not None:
            self.ui.run()

        # Start loop to call refresh for the display
        counter = 0
        while True:
            time.sleep(1.0/elk_bridge_refresh_fps)
            counter += 1

            if not self.start_animation_not_finished:
                self._refresh_display(counter)

            if self.ui is not None:
                if counter < START_ANIMATION_N_FRAMES and self.start_animation_not_finished:
                    self.ui.set_start_animation_frame(counter)
                elif counter == START_ANIMATION_N_FRAMES and self.start_animation_not_finished:
                    self.start_animation_not_finished = False
                self.ui.refresh()

    def _refresh_display(self, counter):
        global connection_with_plugin_ok
        global time_post_state_received
        global plugin_state_xml

        # Before setting new display lines, pre-compute some variables form the state

        # Check plugin connection status
        if time_post_state_received is not None and time.time() - time_post_state_received < 0.5:
            shoudl_state_received_mark = True
        else:
            shoudl_state_received_mark = None
        if time_post_state_received is not None and time.time() - time_post_state_received > old_state_seconds_threshold:
            if connection_with_plugin_ok == True:
                connection_with_plugin_ok = False
                print('* Plugin disconnected')

        # Display first line row with general state info
        is_querying_and_downloading = False
        if plugin_state_xml is not None:
            is_querying_and_downloading = plugin_state_xml.find_all("VolatileState".lower())[0].get('isQueryingAndDownloadingSounds'.lower(), '') != "0"       
        header_line = "SOURCE            {0}{1}{2}".format("Q" if is_querying_and_downloading else " ", "*" if shoudl_state_received_mark else " ", ["|", "/", "-", "\\"][counter % 4])
        display_lines = [header_line]

        # Check if a sound is selected to decide which info to show    
        if self.selected_sound_idx is not None:
            sound_name = ""
            params_labels_values = []
            if plugin_state_xml is not None:
                preset_state = plugin_state_xml.find_all("SourcePresetState".lower())[0]
                sounds_info = preset_state.find_all("soundsInfo".lower())[0].find_all("soundInfo".lower())
                if self.selected_sound_idx < len(sounds_info):
                    sound_info = sounds_info[self.selected_sound_idx]
                    sound_name = sound_info.get('soundname', '-')
                    for parameter_name, _, get_func, parameter_label_template, _ in parameter_pages[self.current_parameter_page]:
                        for parameter in sound_info.find_all('samplersoundparameter'):
                            val = parameter.get('parameter_value', '')
                            if parameter.get('parameter_name', '') == parameter_name:
                                processed_val = get_func(val)
                                params_labels_values.append((parameter_label_template, processed_val))

            display_lines.append("SOUND {0}: {1}".format(self.selected_sound_idx, sound_name))

            for parameter_label_template, param_value in params_labels_values:
                display_lines.append(parameter_label_template.format(param_value))

        else:
            # Get some properties from plugin state
            num_active_voices = 0
            preset_name = ""
            preset_number = 0
            num_loaded_sounds = 0
            if plugin_state_xml is not None:
                volatile_state = plugin_state_xml.find_all("VolatileState".lower())[0]
                num_active_voices = sum([int(element) for element in volatile_state.get('voiceActivations'.lower(), '').split(',') if element])
                preset_state = plugin_state_xml.find_all("SourcePresetState".lower())[0]
                preset_number = int(preset_state.get("presetNumber".lower(), "-1"))
                preset_name = preset_state.get("presetName".lower(), "no name")
                num_loaded_sounds = len(preset_state.find_all("soundsInfo".lower())[0].find_all("soundInfo".lower()))

            # Update lines of text for the display (set_display_lines will trigger display update)
            display_lines += [
                "{0}ºC|c:{1}|m:{2}".format(system_stats.get("temp", "-"), system_stats.get("cpu", "-"), system_stats.get("mem", "-")),
                'Network: ' + system_stats.get("network_ssid", "-"),
                "{0}: {1}".format(preset_number, preset_name),
                "{0} sounds".format(num_loaded_sounds),
            ]
        
        # Send new lines to UI
        if self.ui is not None:
            self.ui.set_display_lines(display_lines)

        # Also save the lines in internal state
        self.display_contents_for_simulator = display_lines


def run_elk_bridge_loop():
    global elk_bridge
    print('* Starting ElkBridge')
    elk_bridge = ElkBridge()
    elk_bridge.run()


# --- Sound downloader ------------------------------------------------------------------------

class SoundDownloader:
    def __init__(self, url, outfile):
        self.old_percent = 0
        self.url = url
        self.outfile = outfile

    def download_progress_hook(self, count, blockSize, totalSize):
        percent = int(count * blockSize * 100 / totalSize)
        if percent > self.old_percent:
            self.old_percent = percent
            osc_client.send_message('/downloading_sound_progress', [self.outfile, percent])
        if percent >= 100:
            osc_client.send_message('/finished_downloading_sound', [self.outfile])


def download_sound(url, outfile):
    if not (os.path.exists(outfile) and os.path.getsize(outfile) > 0):
        # If sound does not exist, start downloading
        print('- Downloading ' + url)
        progress = SoundDownloader(url, outfile)
        urllib.request.urlretrieve(url, outfile, reporthook=progress.download_progress_hook)
    else:
        # If sound already exists, notify plugin about that
        print('- Skip downloading ' + url + ' (already downloaded)')
        osc_client.send_message('/finished_downloading_sound', [outfile])


class DownloadSoundsThread(threading.Thread):

    url = None
    outfile = None

    def __init__(self, _url, _outfile):
        super(DownloadSoundsThread, self).__init__()
        self.url = _url
        self.outfile = _outfile

    def run(self):
        asyncio.set_event_loop(asyncio.new_event_loop())
        download_sound(self.url, self.outfile)


def download_all_sounds(urls, outfiles):
    for url, outfile in zip(urls, outfiles):
        DownloadSoundsThread(url, outfile).start()


# --- HTTP Server ------------------------------------------------------------------------

@http_server.route('/', methods=['GET'])  # Serve main interface HTML file
def index_minimal():
    tvars = {}
    return render_template("index_minimal.html", **tvars)

@http_server.route('/index', methods=['GET'])  # Serve main interface HTML file
def index():
    tvars = {}
    return render_template("index.html", **tvars)

@http_server.route('/simulator', methods=['GET'])  # Serve the interface which simulates blackboard
def simulator():
    tvars = {}
    return render_template("simulator.html", **tvars)

@http_server.route('/simulator_get_display', methods=['GET'])  # Get contents of the display
def simulator_get_display():
    global elk_bridge
    return '<br>'.join(elk_bridge.display_contents_for_simulator)

@http_server.route('/simulator_user_action', methods=['GET'])  # Simulate user pressing a button, knob, etc
def simulator_user_action():
    global elk_bridge
    action = request.args['action']
    value = request.args['value']
    if action.startswith("button"):
        button_idx = int(action.split('_')[2])
        if elk_bridge is not None:
            elk_bridge.handle_buttons(button_idx, value)
    elif action.startswith("slider"):
        slider_idx = int(action.split('_')[1])
        if elk_bridge is not None:
            elk_bridge.handle_faders(slider_idx, float(value))
    elif action.startswith("encoder"):
        sub_action = action.split('_')[1]
        if sub_action == 'rotate':
            elk_bridge.handle_encoder(int(value))
        elif sub_action == 'press':
            elk_bridge.handle_encoder_button(1.0)
        elif sub_action == 'release':
            elk_bridge.handle_encoder_button(0.0)
    return 'Action received'

@http_server.route('/send_osc', methods=['GET'])  # Forwards the request contents as an OSC message to the plugin
def send_osc():
    address = request.args['address']
    values = [getattr(__builtins__, type_name)(value) for type_name, value in zip(request.args['types'].split(';'), request.args['values'].split(';'))]
    osc_client.send_message(address, values)
    return 'OSC sent'

@http_server.route('/state_from_plugin', methods=['POST'])  # Receives a state update from the plugin and saves the contents
def state_from_plugin():
    global plugin_state
    global plugin_state_xml
    global time_post_state_received
    global connection_with_plugin_ok
    global elk_bridge
    time_post_state_received = time.time()
    plugin_state = request.data
    used_parser = "lxml"
    plugin_state_xml = BeautifulSoup(plugin_state, "lxml")
    #print('Time loading XML: {0} ({1})'.format(time.time() - time_post_state_received, used_parser))
    
    if connection_with_plugin_ok == False:
        connection_with_plugin_ok = True
        print('* Plugin connected')
    return 'State received'

@http_server.route('/update_state', methods=['GET'])  # Client requests to get an updated version of the state
def update_state():
    global connection_with_plugin_ok
    if time_post_state_received is not None and time.time() - time_post_state_received > old_state_seconds_threshold:
        if connection_with_plugin_ok == True:
            connection_with_plugin_ok = False
            print('* Plugin disconnected')
        return 'Maybe old'
    else:
        return Response(plugin_state, mimetype='text/xml')

@http_server.route('/get_system_stats', methods=['GET'])  # Return system stats
def get_system_stats():
    if system_stats:
        return "temp={0}\ncpu={1}%\nmem={2}%\nMSW:\n{3}".format(system_stats['temp'], system_stats['cpu'], system_stats['mem'], system_stats['msw'])
    else:
        return "No stats"

@http_server.route('/download_sounds', methods=['GET'])  # Download the sounds requested by the plugin
def download_sounds():
    urls_to_download = []
    outfiles = []
    for url in request.args['urls'].split(','):
        if url:
            sound_id = url.split('/')[-1].split('_')[0]
            outfile = os.path.join(request.args['location'], sound_id + '.ogg')
            urls_to_download.append(url)
            outfiles.append(outfile)
    download_all_sounds(urls_to_download, outfiles)
    return 'Downloading async...'


# --- Main ------------------------------------------------------------------------

class ElkBridgeThread(threading.Thread):
    def run(self):
        asyncio.set_event_loop(asyncio.new_event_loop())
        run_elk_bridge_loop()


class CollectSystemStatsThread(threading.Thread):
    def run(self):
        asyncio.set_event_loop(asyncio.new_event_loop())
        run_collect_system_stats_loop()


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--osc_ip", default="127.0.0.1", help="The IP to send OSC to")
    parser.add_argument("--osc_port", type=int, default=9001, help="The port to send OSC messages to")
    parser.add_argument("--http_port", type=int, default=8123, help="The port the web server should listen at")
    args = parser.parse_args()

    # If on ELK platform, start the thread that will do the communication with the hardware, draw on display, etc.
    if elk_bridge_refresh_fps:
        ElkBridgeThread().start()

    # Also if on ELK platform, start the thread that will collect and update system stats periodically
    if system_stats_refresh_fps:
        collect_system_stats()
        CollectSystemStatsThread().start()

    # Start OSC client to send OSC messages to plugin
    print('* Starting OSCClient')
    osc_client = OSCClient(args.osc_ip, args.osc_port, encoding='utf8')

    print('* Running aconnect')
    get_status_output("aconnect 16 128")

    # Start HTTP server that will receive state updates from the plugin and implements the web interface
    print('* Starting HTTP server at {}'.format(args.http_port))
    http_server.run(host='0.0.0.0', port=args.http_port, debug=True if platform == "desktop" else False)
