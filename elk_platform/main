#!/usr/bin/env python3

import asyncio
import argparse
import glob
import json
import logging
import os
import random
import requests
import subprocess
import sys
import time
import urllib

from collections import defaultdict

from bs4 import BeautifulSoup

try:
    from elkpy import sushicontroller as sc
    from elkpy import sushiprocessor as sp
except ImportError:
    # Not running in ELK platform, no problem as ELK-specific code won't be run
    pass

try:
    from elk_ui_custom import ElkUIController, N_LEDS
except ModuleNotFoundError:
    N_LEDS = 9

from helpers import Timer, frame_from_start_animation, justify_text, START_ANIMATION_DURATION, translate_cc_license_url, StateNames, process_xml_state_from_plugin, process_xml_volatile_state_from_plugin, get_all_sound_usage_logs

from source_states import state_manager, sound_parameters_info_dict, ALLOWED_AUDIO_FILE_EXTENSIONS, get_local_audio_files_path

from freesound_interface import get_access_token_from_code, get_crurrently_logged_in_user, is_logged_in, get_stored_access_token

from flask import Flask, render_template, request, redirect, url_for, Response, jsonify, send_from_directory
from oscpy.client import OSCClient
from oscpy.server import OSCThreadServer
import threading

if sys.platform == "linux" or sys.platform == "linux2":
    platform = "ELK"
else:
    platform = "desktop"

# Configure Flask logging to only show error messages
disable_flask_logging = True
if disable_flask_logging:
    log = logging.getLogger('werkzeug')
    log.setLevel(logging.ERROR)

elk_bridge_refresh_fps = 20
system_stats_refresh_fps = 1
full_state_refresh_fps = 1
volatile_state_refresh_fps = 15

current_frame = None
current_frame_directory = 'static/frame/' 

plugin_state = "No sate"
plugin_state_dict = {}
time_post_state_received = None
connection_with_plugin_ok = False
last_is_querying_and_downloading_sounds_state = False
PLUGIN_DISCONNECTED_THRESHOLD = 8


system_stats = {}

system_stats_thread = None
elk_bridge_thread = None

http_server = Flask(__name__, template_folder='/udata/source/app/' if platform == "ELK" else '../SourceSampler/Resources/')
osc_client = None
elk_bridge = None
osc_server = None

BUTTON_LONG_PRESS_TIME = 0.25
BUTTON_DOUBLE_PRESS_TIME = 0.2


# --- Utils ------------------------------------------------------------------------


def get_status_output(command):
    return os.popen(command).read()[:-1]  # Remove last char which is always \n


last_time_restarting_connman = 0


def collect_system_stats():
    global system_stats
    global last_time_restarting_connman

    if platform == "ELK":

        # Get system stats like cpu usage, temperature, etc.
        try:
            system_stats['temp'] = get_status_output("sudo vcgencmd measure_temp").replace('temp=', '').replace("'C", '')
            system_stats['cpu'] = get_status_output("/bin/grep 'cpu ' /proc/stat | awk '{usage=($2+$4)*100/($2+$4+$5)} END {print usage \"%\"}'")[0:4]
            system_stats['mem'] = get_status_output("free | /bin/grep Mem | awk '{print $3/$2 * 100.0}'")[0:4]
            proc_xenomai_output = get_status_output("/bin/more /proc/xenomai/sched/stat | /bin/grep sushi_b64")
            total_cpu = 0
            for line in proc_xenomai_output.split('\n'):
                total_cpu += float(line.split('sushi_b64')[0].strip().split(' ')[-1])
            system_stats['xenomai_cpu'] = total_cpu
            system_stats['n_sushi_proc'] = get_status_output("/bin/ps -e | /bin/grep sushi | wc -l")
            
            # Check network status and reconnect if disconnected
            connmanctl_services_output = get_status_output("sudo connmanctl services")
            network_is_connected = '*AO' in connmanctl_services_output
            if network_is_connected:
                system_stats['network_ssid'] = connmanctl_services_output.split('*AO ')[1].split(' ')[0]
                last_time_restarting_connman = 0
            else:
                system_stats['network_ssid'] = '-' + ' (R)' if last_time_restarting_connman != 0 else ''
                if time.time() - last_time_restarting_connman > 10:  # Don't try to reconnect more often than every 10 seconds
                    print('* Restarting connman')
                    last_time_restarting_connman = time.time()
                    get_status_output("sudo connmanctl enable wifi")
                    get_status_output("sudo systemctl restart connman")

            # Check aconnect status and reconnect if disconnected                    
            aconnect_l_output = get_status_output("aconnect -l")
            aconnect_is_connected = 'Connected' in aconnect_l_output
            if not aconnect_is_connected:
                print('* Running aconnect')
                out = get_status_output("aconnect 16 128")
                print(out)

        except:
            system_stats = {}


def run_collect_system_stats_loop():
    print('* Starting system stats loop')
    while True:
        time.sleep(1.0/system_stats_refresh_fps)
        collect_system_stats()


def run_collect_volatile_state_loop():
    print('* Starting collect volatile stats loop')
    while True:
        time.sleep(1.0/volatile_state_refresh_fps)
        if osc_client is not None:
            osc_client.send_message('/get_state', ["volatileString"])


def run_collect_full_state_loop():
    print('* Starting collect full stats loop')
    while True:
        time.sleep(1.0/full_state_refresh_fps)
        if osc_client is not None:
            osc_client.send_message('/get_state', ["full"])



# --- ELK Bridge ------------------------------------------------------------------------

class ElkBridge(object):

    buttons_state = {}
    button_pressing_log = defaultdict(list)
    button_timers = [None, None, None, None, None, None, None, None, None]
    
    encoder_pressing_log = []
    encoder_timer = None

    buttons_sent_note_on = {}
    selected_sound_idx = None
    current_parameter_page = 0
    starttime = 0
    ui = None
    sushi = None

    def __init__(self):

        sushi_initialized = False
        while not sushi_initialized:
            try:
                self.sushi = sc.SushiController()
                sushi_initialized = True
                print("Initialized SushiController")
            except Exception as e:
                print('ERROR initializing SushiController: {0}'.format(e))
                if platform == "ELK":
                    time.sleep(1)
                else:
                    break  # break while because this will never succeed
                
        elkui_initialized = False
        while not elkui_initialized:
            try:
                self.ui = ElkUIController(self.handle_faders,
                                          self.handle_buttons,
                                          self.handle_encoder_button,
                                          self.handle_encoder)
                elkui_initialized = True
                state_manager.set_ui_client(self.ui)
                print("Initialized ElkUIController")
            except Exception as e:
                print('ERROR initializing ElkUIController: {0}'.format(e))
                if platform == "ELK":
                    time.sleep(1)
                else:
                    break  # break while because this will never succeed
        self.compute_display_frame(0)

    def is_shift_pressed(self):
        return self.buttons_state.get(0, 0) == 1

    def handle_faders(self, fader_idx, val):
        if not state_manager.block_ui_input:
            state_manager.current_state.on_fader_moved(fader_idx, val, shift=self.is_shift_pressed())

    def handle_buttons(self, button_idx, val):
                
        def delayed_double_press_button_check(button_idx):
            last_time_pressed = self.button_pressing_log[button_idx][-1]
            try:
                previous_time_pressed = self.button_pressing_log[button_idx][-2]
            except IndexError:
                previous_time_pressed = 0
            if last_time_pressed - previous_time_pressed  < BUTTON_DOUBLE_PRESS_TIME:
                # If time between last 2 pressings is shorter than BUTTON_DOUBLE_PRESS_TIME, trigger double press action
                if not state_manager.block_ui_input:
                    state_manager.current_state.on_button_double_pressed(button_idx, shift=self.is_shift_pressed())
            else:
                if not state_manager.block_ui_input:
                    state_manager.current_state.on_button_pressed(button_idx, shift=self.is_shift_pressed())

        is_being_pressed = int(val) == 1 
        if is_being_pressed:
            # Trigger the raw press action
            if not state_manager.block_ui_input:
                state_manager.current_state.on_button_down(button_idx, shift=self.is_shift_pressed())

            # Also when button is pressed, save the current time it was pressed and clear any delayed execution timer that existed
            self.button_pressing_log[button_idx].append(time.time())
            self.button_pressing_log[button_idx] = self.button_pressing_log[button_idx][-2:]  # Keep only last 2 records (needed to check double presses)
            if self.button_timers[button_idx] is not None:
                self.button_timers[button_idx].setClearTimer()
        else:
            # Trigger the raw release action
            if not state_manager.block_ui_input:
                state_manager.current_state.on_button_up(button_idx, shift=self.is_shift_pressed())

            # Also when button is released check the following:
            # * If pressed for longer than BUTTON_LONG_PRESS_TIME, trigger a "long press" action
            # * If pressed for shorter than BUTTON_LONG_PRESS_TIME, set up a delayed action to trigger the button press and decide whether it should be "single" or "double" press
            last_time_pressed = self.button_pressing_log[button_idx][-1]
            if time.time() - last_time_pressed > BUTTON_LONG_PRESS_TIME:
                # If button pressed for long time, trigger long press action
                if not state_manager.block_ui_input:
                    state_manager.current_state.on_button_long_pressed(button_idx, shift=self.is_shift_pressed())
            else:
                self.button_timers[button_idx] = Timer()
                self.button_timers[button_idx].setTimeout(delayed_double_press_button_check, [button_idx], BUTTON_DOUBLE_PRESS_TIME)

        # Updated stored button's state
        self.buttons_state[button_idx] = int(val)

    def handle_encoder_button(self, val):

        def delayed_double_press_encoder_check():
            last_time_pressed = self.encoder_pressing_log[-1]
            try:
                previous_time_pressed = self.encoder_pressing_log[-2]
            except IndexError:
                previous_time_pressed = 0
            if last_time_pressed - previous_time_pressed  < BUTTON_DOUBLE_PRESS_TIME:
                # If time between last 2 pressings is shorter than BUTTON_DOUBLE_PRESS_TIME, trigger double press action
                state_manager.current_state.on_encoder_double_pressed(shift=self.is_shift_pressed())
            else:
                state_manager.current_state.on_encoder_pressed(shift=self.is_shift_pressed())

        is_being_pressed = int(val) == 1 
        if is_being_pressed:
            # Trigger the raw press action
            state_manager.current_state.on_encoder_down(shift=self.is_shift_pressed())

            # Also when encoder is pressed, save the current time it was pressed and clear any delayed execution timer that existed
            self.encoder_pressing_log.append(time.time())
            self.encoder_pressing_log = self.encoder_pressing_log[-2:]  # Keep only last 2 records (needed to check double presses)
            if self.encoder_timer is not None:
                self.encoder_timer.setClearTimer()
        else:
            # Trigger the raw release action
            if not state_manager.block_ui_input:
                state_manager.current_state.on_encoder_up(shift=self.is_shift_pressed())

            # Also when encoder is released check the following:
            # * If pressed for longer than BUTTON_LONG_PRESS_TIME, trigger a "long press" action
            # * If pressed for shorter than BUTTON_LONG_PRESS_TIME, set up a delayed action to trigger the encoder press and decide whether it should be "single" or "double" press
            last_time_pressed = self.encoder_pressing_log[-1]
            if time.time() - last_time_pressed > BUTTON_LONG_PRESS_TIME:
                # If encoder pressed for long time, trigger long press action
                if not state_manager.block_ui_input:
                    state_manager.current_state.on_encoder_long_pressed(shift=self.is_shift_pressed())
            else:
                self.encoder_timer = Timer()
                self.encoder_timer.setTimeout(delayed_double_press_encoder_check, [], BUTTON_DOUBLE_PRESS_TIME)
    

    def handle_encoder(self, direction):
        if not state_manager.block_ui_input:
            state_manager.current_state.on_encoder_rotated(direction, shift=self.is_shift_pressed())
        
    def run(self):

        if self.ui is not None:
            self.ui.run()

        # Start loop to call refresh for the display
        starttime = time.time()
        counter = 0
        leds_have_been_unset_after_animation = False
        while True:
            time.sleep(1.0/elk_bridge_refresh_fps)
            counter += 1
            time_since_start = time.time() - starttime
            if time_since_start < START_ANIMATION_DURATION and state_manager.should_show_start_animation:
                frame = frame_from_start_animation(time_since_start/START_ANIMATION_DURATION, counter)
                if self.ui is not None:
                    led_counter = counter % (N_LEDS + 1)
                    if led_counter == 0:
                        # Stop all leds
                        for i in range(0, N_LEDS):
                            self.ui.set_led(i, 0)
                    else:
                        # Light current led
                        self.ui.set_led(led_counter - 1, 1)
            else:
                if state_manager.should_show_start_animation is True:
                    state_manager.should_show_start_animation = False

                if self.ui is not None:
                    if not leds_have_been_unset_after_animation:
                        for i in range(0, N_LEDS):
                            self.ui.set_led(i, 0)
                        leds_have_been_unset_after_animation = True
                frame = self.compute_display_frame(counter)

            # Save frame to "global_frame" var (used by simulator)
            global current_frame
            current_frame = frame

            # Send new frame to OLED display
            if self.ui is not None:
                self.ui.set_display_frame(frame)
                self.ui.refresh()

    def compute_display_frame(self, counter):
        global connection_with_plugin_ok
        global time_post_state_received
        global plugin_state_dict

        # Process plugin state information and send it to state manager
        source_state = {}

        # Check plugin connection status
        if time_post_state_received is not None and time.time() - time_post_state_received < 0.5:
            should_show_state_received_mark = True
        else:
            should_show_state_received_mark = None
        if time_post_state_received is not None and time.time() - time_post_state_received > PLUGIN_DISCONNECTED_THRESHOLD:
            if connection_with_plugin_ok == True:
                connection_with_plugin_ok = False
                plugin_state_dict = {}
                state_manager.show_global_message("Pl. disconnected :(")
        source_state[StateNames.CONNECTION_WITH_PLUGIN_OK] = connection_with_plugin_ok
        source_state[StateNames.STATE_UPDATED_RECENTLY] = should_show_state_received_mark

        # Check network connection status
        source_state[StateNames.NETWORK_IS_CONNECTED] = '(R)' not in system_stats.get("network_ssid", "-") and system_stats.get("network_ssid", "-").lower() != 'no network'

        # Add other system stats
        source_state[StateNames.SYSTEM_STATS] = system_stats

        # Add plugin-specifc state variables
        source_state.update(plugin_state_dict)
      
        # Send processed state to state manager
        state_manager.update_source_state(source_state)

        # Generate new frame
        frame = state_manager.draw_display_frame()

        return frame


def run_elk_bridge_loop():
    global elk_bridge
    print('* Starting ElkBridge')
    elk_bridge = ElkBridge()
    elk_bridge.run()


# --- Sound downloader ------------------------------------------------------------------------

class SoundDownloader:
    def __init__(self, url, outfile, sound_id, no_report):
        self.old_percent = 0
        self.url = url
        self.outfile = outfile
        self.sound_id = sound_id
        self.no_report = no_report

    def download_progress_hook(self, count, blockSize, totalSize):
        percent = int(count * blockSize * 100 / totalSize)
        if percent > self.old_percent:
            self.old_percent = percent
            if not self.no_report:
                osc_client.send_message('/downloading_sound_progress', [str(self.sound_id), percent])
        if percent >= 100:
            os.rename(self.outfile + '.tmp', self.outfile)
            if not self.no_report:
                osc_client.send_message('/finished_downloading_sound', [str(self.sound_id)])


def download_sound(url, outfile, sound_id, no_report):
    if not (os.path.exists(outfile) and os.path.getsize(outfile) > 0):
        # If sound does not exist, start downloading
        print('- Downloading ' + url)
        progress = SoundDownloader(url, outfile, sound_id, no_report)
        if '/download' in url:
            # Downloading original quality file, add required authorization header
            opener = urllib.request.build_opener()
            opener.addheaders = [('Authorization', 'Bearer {}'.format(get_stored_access_token()))]
            urllib.request.install_opener(opener)
        urllib.request.urlretrieve(url, outfile + '.tmp', reporthook=progress.download_progress_hook)
    else:
        if not no_report:
            # If sound already exists, notify plugin about that
            print('- Skip downloading ' + url + ' (already downloaded)')
            osc_client.send_message('/finished_downloading_sound', [str(sound_id)])


class DownloadSoundsThread(threading.Thread):

    url = None
    outfile = None

    def __init__(self, _url, _outfile, _sound_id, _no_report):
        super(DownloadSoundsThread, self).__init__()
        self.url = _url
        self.outfile = _outfile
        self.sound_id = _sound_id
        self.no_report = _no_report

    def run(self):
        asyncio.set_event_loop(asyncio.new_event_loop())
        download_sound(self.url, self.outfile, self.sound_id, self.no_report)


def download_all_sounds(urls, outfiles, sound_ids, no_report=False):
    for url, outfile, sound_id in zip(urls, outfiles, sound_ids):
        DownloadSoundsThread(url, outfile, sound_id, no_report).start()


# --- HTTP Server ------------------------------------------------------------------------

@http_server.route('/', methods=['GET', 'POST'])  # Serve main interface HTML file
def index_minimal():
    tvars = {'freesound_username': get_crurrently_logged_in_user()}
    if request.method == 'GET':
        return render_template("index_minimal.html", **tvars)
    else:
        local_files_directory = get_local_audio_files_path()
        if local_files_directory is not None:
            n_saved = 0
            uploaded_files = request.files.getlist("file[]")
            for f in uploaded_files:
                if f.filename.split('.')[-1] in ALLOWED_AUDIO_FILE_EXTENSIONS:  # Check that format is ok
                    f.save(os.path.join(local_files_directory, f.filename))
                    n_saved += 1
            tvars.update(message='{} files saved'.format(n_saved))
            return render_template("index_minimal.html", **tvars)
        return render_template("index_minimal.html", message='Errors saving files')

@http_server.route('/update_minimal_interface_state', methods=['GET'])  # Client requests to get an updated version of the state
def update_minimal_interface_state():
    state = {
        'should_ask_for_data': False,
        'should_load_url': False
    }
    if state_manager.is_waiting_for_data_from_web():
        state['should_ask_for_data'] = True
        state['web_form_id'] = state_manager.current_state.web_form_id
        state['web_form_data'] = state_manager.current_state.data_for_web_form_id
    if state_manager.open_url_in_browser is not None:
        state['should_load_url'] = state_manager.open_url_in_browser
        state_manager.open_url_in_browser = None
    return jsonify(state)

@http_server.route('/usage_log', methods=['GET'])  # Serve interface HTML file with all the available controls
def usage_log():
    tvars = {'log': get_all_sound_usage_logs()}
    return render_template("usage_log.html", **tvars)

@http_server.route('/freesound_login_callback', methods=['GET'])  # Serve interface HTML file with all the available controls
def freesound_login_callback():
    code = request.args.get('code')
    get_access_token_from_code(code)
    return redirect(url_for('index_minimal'))

@http_server.route('/index', methods=['GET'])  # Serve interface HTML file with all the available controls
def index():
    tvars = {}
    return render_template("index.html", **tvars)

@http_server.route('/simulator', methods=['GET'])  # Serve the interface which simulates blackboard
def simulator():
    tvars = {}
    return render_template("simulator.html", **tvars)

@http_server.route('/simulator_get_display', methods=['GET'])  # Get contents of the display
def simulator_get_display():
    global current_frame
    global current_frame_directory
    if not os.path.exists(current_frame_directory):
        os.makedirs(current_frame_directory)
    files = glob.glob(os.path.join(current_frame_directory, '*'))
    for f in files:
        os.remove(f)
    path = os.path.join(current_frame_directory, 'frame{0}.jpg'.format(random.randint(0, 9999999)))
    if current_frame is not None:
        current_frame.save(path)
        return path
    else:
        return ''

@http_server.route('/simulator_user_action', methods=['GET'])  # Simulate user pressing a button, knob, etc
def simulator_user_action():
    global elk_bridge
    action = request.args['action']
    value = request.args['value']
    if action.startswith("button"):
        button_idx = int(action.split('_')[2])
        if elk_bridge is not None:
            elk_bridge.handle_buttons(button_idx, value)
    elif action.startswith("slider"):
        slider_idx = int(action.split('_')[1])
        if elk_bridge is not None:
            elk_bridge.handle_faders(slider_idx, float(value))
    elif action.startswith("encoder"):
        sub_action = action.split('_')[1]
        if sub_action == 'rotate':
            elk_bridge.handle_encoder(int(value))
        elif sub_action == 'press':
            elk_bridge.handle_encoder_button(1.0)
        elif sub_action == 'release':
            elk_bridge.handle_encoder_button(0.0)
    return 'Action received'


@http_server.route('/receive_data_from_web', methods=['GET'])  # Endpoint used to recieve data form the web interface (for UI options that require web interface for example)
def receive_data_from_web():
    # "data" is a list of key/value pairs serialized as: key1:value1,key2:value2,key3:value3...
    data = request.args.get('data', "")
    data_dict = {element.split(':')[0]: element.split(':')[1] for element in data.split(',')}
    state_manager.process_data_from_web(data_dict)
    return 'Thanks!'


@http_server.route('/send_osc', methods=['GET'])  # Forwards the request contents as an OSC message to the plugin
def send_osc():
    address = request.args['address']
    values = [getattr(__builtins__, type_name)(value) for type_name, value in zip(request.args['types'].split(';'), request.args['values'].split(';'))]
    osc_client.send_message(address, values)    
    return 'OSC sent'


def process_state_from_plugin(received_plugin_state):
    global plugin_state
    global plugin_state_dict
    global time_post_state_received
    global connection_with_plugin_ok
    global elk_bridge
    global last_is_querying_and_downloading_sounds_state
    plugin_state = received_plugin_state
    time_post_state_received = time.time()

    if str(plugin_state).startswith("b'<?xml version"):
        # State is in XML format, parse it
        used_parser = "lxml"
        plugin_state_xml = BeautifulSoup(plugin_state, "lxml")

        if len(plugin_state_xml.find_all("SourcePresetState".lower())) == 0:
            # Plugin has sent volatile state information only
            volatile_state = process_xml_volatile_state_from_plugin(plugin_state_xml)
            plugin_state_dict.update(volatile_state)
        else:
            # Plugin has sent full state update
            full_state = process_xml_state_from_plugin(plugin_state_xml, sound_parameters_info_dict, current_state=plugin_state_dict)
            plugin_state_dict.update(full_state)
    else:
        # State is sent as a serialized string only (this is the volatile state)
        volatile_state = process_xml_volatile_state_from_plugin(None, str(plugin_state)[2:-1])
        plugin_state_dict.update(volatile_state)

    if not last_is_querying_and_downloading_sounds_state and plugin_state_dict.get(StateNames.IS_QUERYING_AND_DOWNLOADING, False):
        # Stop showing "making query" message because it will be shown in menu bar with "W"
        state_manager.show_global_message("", duration=0)
        last_is_querying_and_downloading_sounds_state = True
    elif last_is_querying_and_downloading_sounds_state and not plugin_state_dict.get(StateNames.IS_QUERYING_AND_DOWNLOADING, False):
        # Finished doing the work 
        last_is_querying_and_downloading_sounds_state = False

    connection_with_plugin_ok = True
    #print('Time loading and parsing XML: {0} ({1})'.format(time.time() - time_post_state_received, used_parser))


@http_server.route('/state_from_plugin', methods=['POST'])  # Receives a state update from the plugin and saves the contents
def state_from_plugin():
    process_state_from_plugin(request.data)
    return 'State received'

@http_server.route('/update_state', methods=['GET'])  # Client requests to get an updated version of the state
def update_state():
    if time_post_state_received is not None and time.time() - time_post_state_received > PLUGIN_DISCONNECTED_THRESHOLD:
        return 'Maybe old'
    else:
        return Response(plugin_state, mimetype='text/xml')

@http_server.route('/get_system_stats', methods=['GET'])  # Return system stats
def get_system_stats():
    if system_stats:
        return "temp={0}\ncpu={1}%|{2}%\nmem={3}%\n".format(system_stats['temp'], system_stats['cpu'], system_stats['xenomai_cpu'], system_stats['mem'])
    else:
        return "No stats"

@http_server.route('/download_sounds', methods=['GET'])  # Download the sounds requested by the plugin
def download_sounds():
    urls_to_download = []
    outfiles = []
    sound_ids = []
    preview_urls = [url for url in request.args['oggUrls'].split(',') if url]
    ids =  [sid for sid in request.args['ids'].split(',') if sid]
    types =  [ty.lower() for ty in request.args['types'].split(',') if ty]
    sizes =  [int(s) for s in request.args['sizes'].split(',') if s]
    extra_preview_files_to_download_urls = []  # This is to download extra previews of sounds which do not need to be notified to plugin
    extra_preview_files_to_download_outfiles = []  # This is to download extra previews of sounds which do not need to be notified to plugin
    MAX_DOWNLOAD_SIZE_FOR_ORIGINAL_FILES = 1024 * 1024 * 15  # 15 MB This should be in sync with MAX_SIZE_FOR_ORIGINAL_FILE_DOWNLOAD in defines.h
    use_original_preference = state_manager.source_state.get(StateNames.USE_ORIGINAL_FILES_PREFERENCE, 'never')

    for (sound_id, ty, preview_url, size) in zip(ids, types, preview_urls, sizes):
        if  (use_original_preference == 'always' or (use_original_preference == 'onlyShort' and size <= MAX_DOWNLOAD_SIZE_FOR_ORIGINAL_FILES)) and ty != 'not_available' and is_logged_in() and ty in ALLOWED_AUDIO_FILE_EXTENSIONS:
            # If downloading original files, construct sound download URL and use proper sound type to store
            # To download original files, users needs to be logged in
            # Also only download original quality files for supported formats, for others use previews
            urls_to_download.append('https://freesound.org/apiv2/sounds/{}/download/'.format(sound_id))
            outfiles.append(os.path.join(request.args['location'], sound_id + '.original.{}'.format(ty)))
            
            # Add urls to download and outfiles to extra lists. This will also be downloaded but the plugin won't be notified
            # This is mainly used to have sound files compatible with the slice editor
            extra_preview_files_to_download_urls.append(preview_url)
            extra_preview_files_to_download_outfiles.append(os.path.join(request.args['location'], sound_id + '.ogg'))
        else:
            # If not downloading original files, trigger download of preview with the URL passed
            urls_to_download.append(preview_url)
            outfiles.append(os.path.join(request.args['location'], sound_id + '.ogg'))

        sound_ids.append(sound_id)

    # Trigger the download of "main" files
    download_all_sounds(urls_to_download, outfiles, sound_ids)

    # Trigger the download of preview files for those files that are also being downloaded in original quality
    # These versions of the files will be used in the slice editor and possibly in other places if the main original quality download does not succeed
    # These download tasks do not report status to the plugin as the plugin is not waiting for them to finish to load any sound
    download_all_sounds(extra_preview_files_to_download_urls, extra_preview_files_to_download_outfiles, sound_ids, no_report=True)

    return 'Downloading async...'


# --- Main ------------------------------------------------------------------------

class ElkBridgeThread(threading.Thread):
    def run(self):
        asyncio.set_event_loop(asyncio.new_event_loop())
        run_elk_bridge_loop()


class CollectSystemStatsThread(threading.Thread):
    def run(self):
        asyncio.set_event_loop(asyncio.new_event_loop())
        run_collect_system_stats_loop()


class RequestVolatileStateThread(threading.Thread):
    def run(self):
        asyncio.set_event_loop(asyncio.new_event_loop())
        run_collect_volatile_state_loop()


class RequestFullStateThread(threading.Thread):
    def run(self):
        asyncio.set_event_loop(asyncio.new_event_loop())
        run_collect_full_state_loop()


def volatile_state_osc_handler(values):
    process_state_from_plugin(values)

class OSCReceiverThread(threading.Thread):
    def run(self):
        asyncio.set_event_loop(asyncio.new_event_loop())
        osc = OSCThreadServer()
        sock = osc.listen(address='0.0.0.0', port=9002, default=True)
        osc.bind(b'/volatile_state_osc', volatile_state_osc_handler)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--osc_ip", default="127.0.0.1", help="The IP to send OSC to")
    parser.add_argument("--osc_port", type=int, default=9001, help="The port to send OSC messages to")
    parser.add_argument("--http_port", type=int, default=8123, help="The port the web server should listen at")
    args = parser.parse_args()
  
    # If on ELK platform, start the thread that will do the communication with the hardware, draw on display, etc.
    if elk_bridge_refresh_fps:
        ElkBridgeThread().start()

    # Also if on ELK platform, start the thread that will collect and update system stats periodically
    if system_stats_refresh_fps:
        collect_system_stats()
        CollectSystemStatsThread().start()

    # Start the thread that will collect and update the plugin state periodically
    # Use different framerates for full state and volatile state
    # Note that plugin SHOULD NOT be sending the state with a timer, but just
    # send it when requested
    if volatile_state_refresh_fps:
        RequestVolatileStateThread().start()

    if full_state_refresh_fps:
        RequestFullStateThread().start()

    # Start OSC client to send OSC messages to plugin
    print('* Starting OSCClient')
    osc_client = OSCClient(args.osc_ip, args.osc_port, encoding='utf8')
    state_manager.set_osc_client(osc_client)

    # Start OSC receiver to receive OSC messages from the plugin
    print('* Starting OSCReceiverThread')
    OSCReceiverThread().start()

    print('* Running aconnect')
    get_status_output("aconnect 16 128")

    # Start HTTP server that will receive state updates from the plugin and implements the web interface
    print('* Starting HTTP server at {}'.format(args.http_port))
    http_server.run(host='0.0.0.0', port=args.http_port, debug=False)
