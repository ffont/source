#!/usr/bin/env python3

import argparse
import json
import logging
import lxml.etree as etree
import os
import requests
import subprocess
import sys
import time
import urllib

try:
    from elkpy import sushicontroller as sc
    from elkpy import sushiprocessor as sp
except ImportError:
    # Not running in ELK platform, no problem as ELK-specific code won't be run
    pass

try:
    from elk_ui import ElkUIController
except ModuleNotFoundError:
    # Not running in ELK platform, no problem as ELK-specific code won't be run
    pass

from flask import Flask, render_template, request, redirect, url_for, Response
from oscpy.client import OSCClient
from threading import Thread

if sys.platform == "linux" or sys.platform == "linux2":
    platform = "ELK"
else:
    platform = "desktop"

# Configure Flask logging to only show error messages
log = logging.getLogger('werkzeug')
log.setLevel(logging.ERROR)

elk_bridge_refresh_fps = 20
system_stats_refresh_fps = 1

plugin_state = "No sate"
plguin_state_xml = None
time_post_state_received = None
connection_with_plugin_ok = False
old_state_seconds_threshold = 5

system_stats = {}

system_stats_thread = None
elk_bridge_thread = None

http_server = Flask(__name__, template_folder='/home/mind/' if platform == "ELK" else '../SourceSampler/Resources/')
osc_client = None
elk_bridge= None


# --- Utils ------------------------------------------------------------------------

def get_status_output(*args, **kwargs):
    p = subprocess.Popen(*args, **kwargs)
    stdout, stderr = p.communicate()
    return p.returncode, stdout, stderr


def collect_system_stats():
    global system_stats

    # Get system stats like cpu usage, temperature, etc.
    try:
        system_stats['temp'] = get_status_output("sudo vcgencmd measure_temp")[1]
        system_stats['cpu'] = get_status_output("grep 'cpu ' /proc/stat | awk '{usage=($2+$4)*100/($2+$4+$5)} END {print usage \"%\"}'")[1]
        system_stats['mem'] = get_status_output("free | grep Mem | awk '{print $3/$2 * 100.0}'")[1]
        system_stats['network_ssid'] = get_status_output("iwgetid")[1]
        system_stats['msw'] = "CPU  PID    MSW        CSW        XSC        PF    STAT       %CPU  NAME\n" + get_status_output("more /proc/xenomai/sched/stat | grep sushi_b64")[1]
    except:
        system_stats = {}


def run_collect_system_stats_loop():
    print('* Starting system stats loop')
    while True:
        time.sleep(1.0/system_stats_refresh_fps)
        collect_system_stats()


# --- ELK Bridge ------------------------------------------------------------------------

class ElkBridge(object):
    
    def __init__(self):
        self.ui = ElkUIController(self.handle_faders,
                                  self.handle_buttons,
                                  self.handle_encoder_button,
                                  self.handle_encoder)

        self.sushi = sc.SushiController()
        self._refresh_display()

    def handle_faders(self, fader_idx, val):
        print('Fader {0} moved: {1}'.format(fader_idx, val))

    def handle_buttons(self, button_idx, val):
        print('Button {0} pressed: {1}'.format(button_idx, val))

    def handle_encoder_button(self, val):
        print('Encoder button pressed: {0}'.format(val))

    def handle_encoder(self, direction):
        print('Encoder rotated: {0}'.format(direction))

    def run(self):
        self.ui.run()

        # Light leds
        for i in range(0, 9):
            self.ui.set_led(i, 1)

        # Start loop to call refresh for the display
        counter = 0
        while True:
            time.sleep(1.0/elk_bridge_refresh_fps)
            
            counter += 1
            if counter % 3 == 0:
                self._refresh_display()  # At 1/3 of the rate of elk_bridge_refresh_fps, also update the full contents of the display

            self.ui.refresh()

    def _refresh_display(self):
        # Before setting new display lines, pre-compute some variables form the state
        
        # Check plugin connection status
        if time_post_state_received is not None and time.time() - time_post_state_received > old_state_seconds_threshold:
            if connection_with_plugin_ok == True:
                connection_with_plugin_ok = False
                print('* Plugin disconnected')

        # Get some properties from plugin state
        num_active_voices = 0
        preset_name = ""
        preset_number = 0
        num_loaded_sounds = 0
        if plguin_state_xml is not None:
            volatile_state = plguin_state_xml.findall("VolatileState")[0]
            num_active_voices = sum([int(element) for element in volatile_state.get('voiceActivations', '').split(',') if element])
            preset_state = plguin_state_xml.findall("SourcePresetState")[0]
            preset_number = int(preset_state.get("presetNumber", "-1"))
            preset_name = int(preset_state.get("presetName", "no name"))
            num_loaded_sounds = len(preset_state.findall("soundsInfo")[0].findall("soundInfo"))
            
        # Update lines of text for the display (set_display_lines will trigger display update)
        self.ui.set_display_lines([
            "Source is runnning :)",
            system_stats.get("temp", "-"),
            'Network: ' + system_stats.get("network_ssid", "-"),
            "Plugin is online" if connection_with_plugin_ok else "Plugin is offline",
            "{0}: {1} ({2} sounds)".format(preset_number, preset_name, num_loaded_sounds),
            "Active voices: {}".format(num_active_voices), 
        ])


def run_elk_bridge_loop():
    print('* Starting ElkBridge')
    elk_bridge = ElkBridge()
    elk_bridge.run()


# --- Sound downloader ------------------------------------------------------------------------

class SoundDownloader:
    def __init__(self, url, outfile):
        self.old_percent = 0
        self.url = url
        self.outfile = outfile

    def download_progress_hook(self, count, blockSize, totalSize):
        percent = int(count * blockSize * 100 / totalSize)
        if percent > self.old_percent:
            self.old_percent = percent
            osc_client.send_message('/downloading_sound_progress', [self.outfile, percent])
        if percent >= 100:
            osc_client.send_message('/finished_downloading_sound', [self.outfile])    


def download_sound(url, outfile):
    if not (os.path.exists(outfile) and os.path.getsize(outfile) > 0):
        # If sound does not exist, start downloading
        print('- Downloading ' + url)
        progress = SoundDownloader(url, outfile)
        urllib.request.urlretrieve(url, outfile, reporthook=progress.download_progress_hook)
    else:
        # If sound already exists, notify plugin about that
        print('- Skip downloading ' + url + ' (already downloaded)')
        osc_client.send_message('/finished_downloading_sound', [outfile])    


def download_all_sounds(urls, outfiles):
    for url, outfile in zip(urls, outfiles):
        thread = Thread(target = download_sound, args = (url, outfile, ))
        thread.start()


# --- HTTP Server ------------------------------------------------------------------------

@http_server.route('/', methods = ['GET'])  # Serve main interface HTML file
def index():        
    tvars = {}
    return render_template("index.html", **tvars)


@http_server.route('/send_osc', methods=['GET'])  # Forwards the request contents as an OSC message to the plugin
def send_osc():
    address = request.args['address']
    values = [getattr(__builtins__, type_name)(value) for type_name, value in zip(request.args['types'].split(';'), request.args['values'].split(';'))]
    osc_client.send_message(address, values)
    return 'OSC sent'


@http_server.route('/state_from_plugin', methods = ['POST'])  # Receives a state update from the plugin and saves the contents
def state_from_plugin():
    global plugin_state
    global plguin_state_xml
    global time_post_state_received
    global connection_with_plugin_ok
    time_post_state_received = time.time()
    plugin_state = request.data
    plguin_state_xml = etree.fromstring(plugin_state)
    #print(etree.tostring(plguin_state_xml, pretty_print=True).decode("utf-8"))  # To pretty print state
    if connection_with_plugin_ok == False:
            connection_with_plugin_ok = True
            print('* Plugin connected')
    return 'State received'


@http_server.route('/update_state', methods = ['GET'])  # Client requests to get an updated version of the state
def update_state():
    global connection_with_plugin_ok
    if time_post_state_received is not None and time.time() - time_post_state_received > old_state_seconds_threshold:
        if connection_with_plugin_ok == True:
            connection_with_plugin_ok = False
            print('* Plugin disconnected')
        return 'Maybe old'
    else:
        return Response(plugin_state, mimetype='text/xml')


@http_server.route('/get_system_stats', methods = ['GET'])  # Return system stats
def get_system_stats():
    if system_stats:
        return "{0}\ncpu={1}%\nmem={2}%\nMSW:\n{3}".format(system_stats['temp'], system_stats['cpu'], system_stats['mem'], system_stats['msw'])
    else:
        return "No stats"


@http_server.route('/download_sounds', methods = ['GET'])  # Download the sounds requested by the plugin
def download_sounds():
    urls_to_download = []
    outfiles = []
    for url in request.args['urls'].split(','):
        if url:
            sound_id = url.split('/')[-1].split('_')[0]
            outfile = os.path.join(request.args['location'], sound_id + '.ogg')
            urls_to_download.append(url)
            outfiles.append(outfile)
    
    thread = Thread(target = download_all_sounds, args = (urls_to_download, outfiles, ))
    thread.start()
    return 'Downloading async...'


# --- Main ------------------------------------------------------------------------

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--osc_ip", default="127.0.0.1", help="The IP to send OSC to")
    parser.add_argument("--osc_port", type=int, default=9000, help="The port to send OSC messages to")
    parser.add_argument("--http_port", type=int, default=8123, help="The port the web server should listen at")
    args = parser.parse_args()

    if platform == "ELK":
        # If on ELK platform, start the thread that will do the communication with the hardware, draw on display, etc.
        elk_bridge_thread = Thread(target=run_elk_bridge_loop)
        elk_bridge_thread.start()

        # Also if on ELK platform, start the thread that will collect and update system stats periodically
        system_stats_thread = Thread(target=run_collect_system_stats_loop)
        system_stats_thread.start()

    # Start OSC client to send OSC messages to plugin
    print('* Starting OSCClient')
    osc_client = OSCClient(args.osc_ip, args.osc_port, encoding='utf8')

    # Start HTTP server that will receive state updates from the plugin and implements the web interface
    print('* Starting HTTP server at {}'.format(args.http_port))
    http_server.run(host='0.0.0.0', port=args.http_port, debug=False)
