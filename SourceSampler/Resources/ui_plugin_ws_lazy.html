<!DOCTYPE html>
<html>

<head>
    <title>Source, a Freesound Commmunity Sampler</title>
    <script src="https://code.jquery.com/jquery-3.6.0.js"></script>
    <script src="adsr-envelope/build/adsr-envelope.js"></script>
    <script src="https://unpkg.com/wavesurfer.js"></script>
    <script src="https://unpkg.com/wavesurfer.js/dist/plugin/wavesurfer.regions.min.js"></script>
    <script src="jQuery-Knob/dist/jquery.knob.min.js"></script>


    <style>

        /** Define global background variable for dark mode switch **/

        :root {
            --dark-mode: #1d5eb2;
            --light-mode: #e0e0e0;
            --background-color: #f2f1f1;
        }

        body {
            box-sizing: border-box;
            margin: 20px;
            width:100%;
            height: 100vh;
            font-family: "Lucida Console", "Courier New", monospace;
            display:flex;
            justify-content: center;
            align-items: center;
        }

        .container {
        display: grid;
        box-shadow:  -5px -5px 10px #5a5a5a,
             5px 5px 10px #5a5a5a;
        border-radius: 10px;
        grid-template-columns: repeat(10,1fr);
        grid-template-rows: 70px repeat(10,1fr) 30px;
        grid-template-areas:
            "header header header header"
            "main main . sidebar"
            "footer footer footer footer";
        column-gap: 10px;
        background-color:var(--background-color);
        height: 850px;
        width: 1000px;
        margin-top:  80px;
        margin-bottom: 100px;
        }

        .query-parameters {
            display:grid;
            grid-row: 2/3;
            grid-column: 3/9;
            grid-template-rows: repeat(4,1fr);
            grid-template-columns: repeat(3,1fr);

        }

        /**General settings **/
        p {
            user-select: none;
        }


        #q-par {
            display:flex;
            grid-row:2/5;
            grid-column:1/3;
            gap: 40px;
            margin-top:10px;
        }
        

        .query-search {
            display: flex;
            grid-row: 1/2;
            grid-column:1/4;
            border: none;
            width:100%;
            height: auto;
            background: var(--background-color);
            justify-content: center;

        }

        .query-text {
            font-family: "Lucida Console", "Courier New", monospace;
            font-size: 12px;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            box-shadow: inset 5px -5px 10px #dcdbdb,
            inset -5px 5px 10px #ffffff;
            

        }

        .query-button{
            border-radius: 10px;
            width: 50px;
            background: var(--background-color);
            box-shadow: -5px 5px 10px #c5c5c5,
             5px -5px 10px #fbfbfb;
                    }
        
        .slider-regular {
            position: relative;
            display: flex;
            width: 120px;
            height: 20px;
            border-radius: 5px;
            border: 0.08em solid purple;
            background: #f2f1f1;
            box-shadow:  -5px 5px 10px #c2c1c1,
             5px -5px 10px #ffffff;
        }

        input[type="range"] {
            width:120px;
            background-color: var(--background-color);
        }

        input[type="range"]::-webkit-slider-runnable-track {
            height: 10px;
            width: 110px;
            border-radius: 10px;
            background-color: red;
        }

        input[type="range"]::-webkit-slider-thumb {
            -moz-appearance: none !important;
            appearance: none !important;
            position: relative;
            border-radius: 3px;
            height: 60px;
            width: 20px;
            background: #f2f1f1;
            cursor: pointer;
            }
        input[type="range"]::-moz-range-thumb {
            -moz-appearance: none !important;
            appearance: none !important;
            position: relative;
            border-radius: 3px;
            height: 30px;
            width: 20px;
            border: none;
            box-shadow:  -5px 5px 10px #c2c1c1,
             5px -5px 10px #ffffff;
            background: #f2f1f1;
            cursor: pointer;
            }
        .range-text {
                position: absolute;
                top: 4px;
                font-family: "Lucida Console", "Courier New", monospace;;
                left: 8px;
                user-select: none;
                display: flex;
                justify-content: center;
                align-items: center;
                background: #f2f1f1;
                text-align: center;
                height: 10px;
                width: 10px;
                }

        input[type="range"]::-ms-fill-lower{
            background-color: pink;
        }


        *, *::before, *::after {
        box-sizing: border-box;
        }
        :root {
        --colorMain: white;
        --brShadow: -6px 6px 15px rgb(80, 1, 80);
        --tlShadow: 6px -6px 15px rgb(255, 234, 0);
        }

        .freesound {
            grid-row:1/2;
            grid-column: 6/10;
            display: flex;
            align-content: flex-end;
            font-size: 1.1em;
            transform: rotate(-0deg);
            color: white;
            font-weight: bold;
        }

        .freesound p {
            position: absolute;
            bottom: 0;
            left: 0;

        }
        .source-icon{
            grid-row:1/2;
            grid-column: 2/4;
            transform: rotate(-20deg);
            text-align:center;
            margin-left: -90px;
            margin-top:50px;
            color: var(--colorMain);
            font-size: 4.1em;
            font-weight: bold;
            font-family: "Lucida Console", "Courier New", monospace;
            text-transform: uppercase;
            text-shadow: var(--brShadow),
                        var(--tlShadow);

            &::before, &::after {
                position: absolute;
                background: var(--colorMain);
                content: '';
                border-radius: 10%;

            }

            &::before {
            left: 0;
            width: 100px;
            height: 100px;
            top: -150px;
            z-index: 10;
            box-shadow: inset var(--brShadow),
                        inset var(--tlShadow) ;

            }
            &::after {
            left: -50px;
            width: 200px;
            height: 200px;
            top: -200px;
            box-shadow: var(--brShadow),
                        var(--tlShadow) ;
            }
        }



        .bar {
        position: relative;
        float: left;
        display: flex;
        }

        .first {
        width:6px;
        height:1px;
        margin-top:17px;
        background: black;
        border-radius: 4px;
        margin-left: 8px;

        }

        .second {
        width: 2px;
        height: 13px;
        background: black;
        margin-left: 3px;
        margin-top: 10px;
        border-radius: 4px;
        }

        .third {
        width: 3px;
        height: 25px;
        background: black;
        margin-left: 2px;
        border-radius: 4px;
        margin-top: 4px;

        }

        .fourth {
        width: 2px;
        height: 21px;
        background: black;
        margin-left: 2px;
        margin-top: 8px;
        border-radius: 4px;

        }

        .fifth {
        width: 3px;
        height: 27px;
        background: black;
        margin-left: 2px;
        margin-top: 5px;
        border-radius: 4px;

        }
        .sixth {
        width: 2px;
        height: 15px;
        background: black;
        margin-left: 2px;
        margin-top: 10px;
        border-radius: 4px;

        }
        .last {
        width:6px;
        height:2px;
        margin-top:17px;
        background: black;
        margin-left: 3px;
        border-radius: 4px;
        }

        input[type="button"] {
            width: auto;
            height: auto;
            border: none;
        }
        *:focus {
            outline: none;
        }

        .waveform {
            display: grid;
            grid-row: 3/5;
            grid-column: 2/6;
            background: var(--background-color);
            margin-top: 10px;
            border-radius: 2%;
            z-index:1000;
            grid-template-rows: repeat(4,1fr);
            box-shadow:  -5px -5px 0px #d4d2d2,5px 5px 0px #ffffff;

        }
        #waveform {
            grid-row:1/4;
            grid-column: 1/6;
            z-index:4000;
        }

        #waveform wave {
            width: 100%;
            height: 100%;
        }
        .launch-mode {
            display: grid;
            grid-row: 4/5;
            grid-column: 1/6;
            grid-template-columns: repeat(6,1fr);
            background: var(--background-color);
            border-radius: 3px;
            box-shadow: 5px -5px 200px #b3b3b3,-5px 5px 5px #ffffff;
            z-index: 2;
            justify-content: center;
            align-items: center;
        }

        .left-arrow {
            grid-column: 2/3;
            width: 100%;
            height: 100%;
        }

        .left-arrow-inner {
            width: 0;
            height: 0;
            margin-top: 10px;
            margin-left: 25px;
            background: var(--background-color);
            border-top: 10px solid transparent;
            border-bottom: 10px solid transparent;
            border-right:10px solid black;
        }

        .left-arrow-inner:hover{
            border-right:10px solid purple;
        }


        .right-arrow {
            grid-column: 5/6;
            width: 100%;
            height: 100%;

        }

        .right-arrow-inner {
            width: 0;
            height: 0;
            margin-top: 10px;
            background: var(--background-color);
            border-top: 10px solid transparent;
            border-bottom: 10px solid transparent;
            border-left: 10px solid black;
            margin-left: 15px;

        }

        .right-arrow-inner:hover{
            border-left: 10px solid purple;
        }

        .outer-box{
            display: grid;
            grid-column: 3/5;
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 5%;
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 1;
            background: var(--background-color);
            box-shadow:  5px 5px 5px #babdb6;
            }

        .inner-box {
            display: flex;
            width: 80px;
            height: 25px;
            border: none;
            z-index: 2;
            background: black;
            border-radius: 5%;
            align-items: center;
            justify-content: center;
            text-align: center;
            border: 0.2em solid purple;
            }

        .outer-box .inner-box p {
            color: white;
        }
        .adsr {
            display:grid;
            grid-row: 5/7;
            grid-column: 2/6;
            box-shadow: rgb(204, 219, 232) 3px 3px 6px 0px inset, rgba(255, 255, 255, 0.5) -3px -3px 6px 1px inset;
            margin-top: 10px;
            border: none;
            align-items: center;

        }

        #adsr-envelope{
            width:100%;
            max-width:100%;
            height:95%;
            border: none;
            box-shadow:  -5px -5px 0px #d4d2d2,5px 5px 0px #ffffff;
            }


        .adsr-envelope-knobs {
            display: grid;
            grid-gap:5px;
            grid-row: 7/10;
            grid-column: 2/6;
            grid-template-columns: repeat(4,1fr);
            grid-template-rows: 40px repeat(2,1fr);
            border-radius: 3%;
            background: #f2f1f1;
            box-shadow:  -5px 5px 10px #eaeaea,5px -5px 10px #ffffff;
            margin-top: 10px;

        }

        .adsr-filter {
            grid-row:1/2;
            grid-column: 1/3;
            text-align: center;
            border-radius: 5%;
            user-select: none;
            font-weight: none;

        }
        .adsr-amplitude {
            grid-row: 1/2;
            grid-column: 3/5;
            text-align: center;
            border-radius: 5%;
            font-weight: none;
        }

        .adsr-first-knob {
            display: flex;
            grid-row: 2/3;
            grid-column: 1/6;
            gap: 60px;
            margin-left: 15px;
            

        }
        .adsr-second-knob {
            display:flex;
            flex-direction: row;
            grid-row: 3/4;
            grid-column: 1/6;
            margin-left: 65px;
            gap: 60px;

        }

        .canvas {
            display:flex;
        }

        .knob-inner {
            display: flex;
            align-items: center;
            margin-left: 40px;
            width:32px;
            height: 32px;
            margin-top:-60px;
            border-radius: 50px;
            background: linear-gradient(45deg, #dad9d9, #ffffff);
            box-shadow:  5px -5px 6px #e3e3e3,
                        -5px 5px 6px #ffffff;
        }

        /***5px 5px 6px #9d9d9d, 5px -5px 70px #fff This is for bumpy knob? what to do**/
        .knob-circle {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            margin: 0% auto;
            margin-left: 1px;
            border: 1px solid purple;
        }

        .sound-list {
            grid-row: 3/5;
            grid-column: 6/10;
            margin-top: 10px;
            border-radius: 10px;
            background: #f2f1f1;
            box-shadow:  -5px -5px 0px #d4d2d2,5px 5px 0px #ffffff;
        }

        #sound-dropdown {
            width: 100%;
            height: 100%;
            font-family: "Lucida Console", "Courier New", monospace;
            border: none;
            border-radius: 5%;
            background: #f2f1f1;
            box-shadow: inset 5px -5px 10px #e3e3e3,
                        inset -5px 5px 10px #ffffff;

        }

        p {
            color: purple;
        }
        
        .parameter-knobs {
            display: grid;
            grid-row: 5/10;
            grid-column: 6/10;
            grid-template-rows: repeat(10,1fr);
            background: #f2f1f1;
            box-shadow:  -5px 5px 10px #eaeaea,5px -5px 10px #ffffff;
            margin-top: 10px;
            border-radius: 3%;
            row-gap: 5px;
        }

        .reverb-header {
            grid-row: 1/2;
            text-align: center;
            font-size: 18px;
        }

        .reverb-knob-area {
            grid-row: 2/4;
            display: flex;
            align-content: center;
            gap:60px;
            margin-left: 20px;
        }

        .modulation-header {
            grid-row:4/5;
            text-align: center;
            font-size:18px;
                }
        .modulation-knob-area {
            grid-row: 5/7;
            display: flex;
            gap: 65px;
            margin-left: 65px;
        }
        .velocity-header {
            grid-row: 7/8;
            text-align: center;
            font-size: 18px;
        }
        .velocity-knob-area{
            grid-row: 8/10;
            display: flex;
            gap: 80px;
            margin-left: 110px;

        }

        #keyboard {
            grid-row:10/12;
            grid-column:2/8;
            border: 1px solid black;            
            border-radius: 5%;
            width: auto;
            height: auto;
            border: none;
        }
        #keyboard li:first-child {
            border-radius: 5px 0 5px 5px;
            margin-left:-40px;
            }

        #keyboard li:last-child {
            border-radius: 0 5px 5px 5px;
            }

        .white-key,
        .black-key {
            position: relative;
            float: left;
            display: flex;
            user-select: none;
            cursor: pointer;
        }
        .white-key {
            height: 7.5rem;
            width: 3.0rem;
            z-index: 1;
            border-left: 1px solid hsl(0, 0%, 84%);
            border-bottom: 1px solid hsl(0, 0%, 84%);
            border-radius: 0 0 5px 5px;
            background: var(--background-color);
            box-shadow:  -5px 5px 10px #e7e7e7,
                        5px -5px 10px #ffffff;
            color: var(--black-30);
            }

        .black-key {
            height: 4.5rem;
            width: 1.5em;
            margin: 0 0 0 -1rem;
            z-index: 2;
            border: 1px solid purple;
            border-radius: 0 0 3px 3px;
            box-shadow: -1px -1px 2px var(--white-20) inset,
                0 -5px 2px 3px var(--black-60) inset, 0 2px 4px var(--black-50);
            background: linear-gradient(45deg, hsl(0, 95%, 22%) 0%, hsl(0, 89%, 29%) 100%);
            color: var(--white-50);
            }
            .offset {
            margin: 0 0 0 -1rem;
            }
        .pitch-section {
            grid-row:10/12;
            grid-column:8/10;
            display: flex;
            justify-content: center;
            margin-top: 60px;

        }


    </style>

    <script>

        $(function(){
            $(".knob-1").knob({
                'min':0,
                'max':1,
                'step':0.01,
                'width':45,
                'height':45,
                'displayInput': true,
                'thickness': 0.2,
                'angleOffset':180,
                'fgColor': 'purple',
                'bgColor':'#dad9d9',
                'font': '"Lucida Console", "Courier New", monospace',
                'change': function(v) {
                    ss.setSoundParameter(this['$'][0]['id'],v,0,1);
                    if (adsrList.includes(this['$'][0]['id'])){
                        drawAdsrEnvelope();
                    }
                }
            });

            $(".knob-reverb").knob({
                'min':0,
                'max':1,
                'step':0.01,
                'width':45,
                'height':45,
                'displayInput': true,
                'thickness': 0.2,
                'angleOffset':180,
                'fgColor': 'purple',
                'bgColor':'#dad9d9',
                'font': '"Lucida Console", "Courier New", monospace',
                'change': function(v) {
                    //Set reverb parameter to the new value
                    reverbParams[this['$'][0]['id']] = v;
                    ss.setReverbParameters();
                }
            });

            $(".knob-100").knob({
                'min':0,
                'max':100,
                'step':0.01,
                'width':45,
                'height':45,
                'displayInput': true,
                'thickness': 0.2,
                'angleOffset':180,
                'fgColor': 'purple',
                'bgColor':'#dad9d9',
                'change': function(v) {
                    ss.setSoundParameter(this['$'][0]['id'],v,0,1);
                }
            });

            $(".knob-12").knob({
                'min':-12,
                'max':12,
                'step':0.01,
                'width':45,
                'height':45,
                'displayInput': true,
                'thickness': 0.2,
                'angleOffset':180,
                'fgColor': 'purple',
                'bgColor':'#dad9d9',
                'change': function(v) {
                    ss.setSoundParameter(this['$'][0]['id'],v,0,1);
                }
            });

            $(".knob-2000").knob({
                'min':10,
                'max':20000,
                'step':1,
                'width':45,
                'height':45,
                'displayInput': true,
                'thickness': 0.2,
                'angleOffset':180,
                'fgColor': 'purple',
                'bgColor':'#dad9d9',
                'change': function(v) {
                    ss.setSoundParameter(this['$'][0]['id'],v,0,1)
                }
            });
        });


        let ss = undefined;  // Will keep source plugin state and has util methods to interact with it
        let httpPort = undefined;
        let useHttps = undefined;
        let hostname = undefined;

        //Define a global selected sound
        var selectedSoundUUID = null;

        //Sound list for play and remove
        let playStopSoundList = [];

        //ADSR lists
        let adsrList = ["attack","decay","release","sustain", "filterAttack","filterDecay","filterRelease","filterSustain"]
        let launchModes = ['gate', 'loop', 'loopfb', 'trigger'];

        //Reverb parameters
        let reverbParams = {'roomSize':0, 'damping':0, 'wetLevel':0, 'dryLevel':0, 'width':0,'freezeMode':0}

        //Knob parameters
        let knobParameterNamesAmp = ["attack", "decay", "sustain", "release","gain","pan", 
                                    "mod2CutoffAmt", "mod2GainAmt", "mod2PitchAmt","vel2CutoffAmt", "vel2GainAmt",
                                "roomSize","damping","wetLevel","dryLevel"]
        let knobParameterNamesFilter = ["filterAttack", "filterDecay","filterRelease","filterCutoff","filterRessonance",
                                        "roomSize","damping","wetLevel","dryLevel",
                                        "mod2CutoffAmt", "mod2GainAmt", "mod2PitchAmt", "vel2CutoffAmt", "vel2GainAmt"]
        //ADSR initial dictionary
        let DefaultParams = {
                attackTime: 0.1,
                decayTime: 0.1,
                sustainLevel: 0.1,
                releaseTime: 0.1,
                gateTime: 1,
                peakLevel: 1,
                epsilon: 0.001,
                attackCurve: "exp",
                decayCurve: "exp",
                releaseCurve: "exp",
                };

        var expStrength = 2;  // For sliders

        window.AudioContext = window.AudioContext || window.webkitAudioContext; // Audio context used for loading audio for drawing waveforms
        const audioContext = new AudioContext();



        let lastUIAction = 0;


        class StateSynchronizer {  // Class to synchronize with plugin's state and interact with it

            constructor(wsPort, useWss) {
                this.state = undefined;
                this.volatileState = undefined;
                this.volatileStateRequestTimer = undefined;
                this.volatileStateRequestTimerInterval = 100;
                this.parser = new DOMParser();

                this.wsPort = wsPort;
                this.useWss = useWss;
                this.wsConnection = this.configureWSConnection();

                this.afterStateUpdatesFullStateRequestTimer = undefined;
                this.afterStateUpdatesFullStateRequestTimerInterval = 1000;
            }

            scheduleExtraFullStateRequestAfterBurstOfMessages () {
                // Because sometimes there can be state syncing issues if messages arrive in wrong orders or due to
                // other whings we did not contemplate, once a burst of state update messages has finished, we call request
                // once more a full state update to make sure everything is perfectly in sync.
                if (this.afterStateUpdatesFullStateRequestTimer !== undefined){
                    clearTimeout(this.afterStateUpdatesFullStateRequestTimer);
                    this.afterStateUpdatesFullStateRequestTimer = undefined;
                }
                this.afterStateUpdatesFullStateRequestTimer = setTimeout(() => {
                    this.requestFullState();
                }, this.afterStateUpdatesFullStateRequestTimerInterval);
            }

            configureWSConnection () {
                let wsUrl = "";
                if (this.useWss){
                    wsUrl = "wss://" + hostname + ":" + this.wsPort + "/source_coms/";
                } else {
                    wsUrl = "ws://" + hostname + ":" + this.wsPort + "/source_coms/";
                }
                console.log("Connecting to WS server: " + wsUrl);
                let socket = new WebSocket(wsUrl);

                let self = this;

                socket.onopen = function(e) {
                    console.log("[WS open] Connection established");

                    // Once connection established, request full state once and start polling volatile state
                    self.requestFullState();
                    self.volatileStateRequestTimer = setInterval(function () {
                        self.requestVolatileState();
                    }, self.volatileStateRequestTimerInterval);
                };

                socket.onclose = function(event) {
                    if (event.wasClean) {
                        console.log(`[WS close] Connection closed cleanly, code=${event.code} reason=${event.reason}`);
                    } else {
                        console.log('[WS close] Connection died');
                    }
                    setTimeout(() => {
                        self.configureWSConnection (); // Start again connection if it fails, wait 2 seconds
                    }, 2000);

                };

                socket.onerror = function(error) {
                    console.log(`[WS error] ${error.message}`);
                };

                socket.onmessage = function(event) {
                    const msgTypeSeparatorPosition = event.data.indexOf(':');
                    const msgType = event.data.slice(0, msgTypeSeparatorPosition);
                    const rawData = event.data.slice(msgTypeSeparatorPosition + 1, event.data.length);


                    //PROBLEM HERE IS THAT FULL STATE MSG IS COMING BUT VOLATILE IS MORE? HOW TO SOLVE THIS?
                    if (msgType === "/full_state"){
                        const updateIdSeparatorPosition = rawData.indexOf(';');
                        const updateId = parseInt(rawData.slice(0, updateIdSeparatorPosition), 10);
                        const dataToParse = rawData.slice(updateIdSeparatorPosition + 1, rawData.length);
                        self.state = self.parser.parseFromString(dataToParse, "text/xml");
                        updateFullUI();

                    } else if (msgType === "/volatile_state"){
                        self.volatileState = self.parser.parseFromString(rawData, "text/xml");
                        updateVolatileUI();

                    } else if (msgType === "/state_update"){

                        if (ss.state === undefined){
                            // If no state is present, ignore stat update messages as these will fail
                            // also request full state to get in sync again
                            self.requestFullState();
                            return;
                        }

                        const rawDataParts = rawData.split(';');
                        const updateType = rawDataParts[0];
                        const updateId = parseInt(rawDataParts[1], 10);
                        const restOfDataSliced = rawDataParts.slice(2, rawDataParts.length);

                        if (updateType === 'propertyChanged'){
                            const treeUUID = restOfDataSliced[0];
                            const treeType = restOfDataSliced[1];
                            const propertyName = restOfDataSliced[2];
                            const propertyValue = restOfDataSliced[3];

                            const elementToUpdate = self.state.querySelector("[uuid='" + treeUUID + "']");
                            if (elementToUpdate !== null){
                                elementToUpdate.setAttribute(propertyName, propertyValue);


                                // If property was found, trigger corresponding UI updates
                                if (treeType === "SOUND"){
                                    // If what changed is a property of a sound or sound sample, then update the sound list
                                    var sound = ss.getSoundFromSoundUUID(treeUUID);
                                    //If sound exists and not in the deleted mode,
                                    if ((sound !== null) && (propertyName !== "willBeDeleted" && propertyName === "downloadCompleted")){
                                        console.log(propertyName);
                                        updateSoundList(sound.getAttribute('uuid'));
                                    } else {

                                    }

                                    // If the property name is that of a slider (sound parameter), then update the slider as well
                                    if (isSoundParameter(propertyName)){
                                        // NOTE: in that case, treeUUID will always correspond to a SOUND element
                                        updateSoundParameter(treeUUID, propertyName, propertyValue, elementToUpdate);
                                    }
                                } else if (treeType === "SOUND_SAMPLE"){
                                    var sound = ss.getSoundFromSoundSampleUUID(treeUUID);

                                    //If the property belongs to querying, add the sounds to the sound list
                                    if ((sound !== null) && (propertyName !== "willBeDeleted" && propertyName === "downloadCompleted")){
                                        console.log('sound_sample',propertyName);
                                        updateSoundList(sound.getAttribute('uuid'));
                                    } else {
                                        // We might receive property change messages from sounds that are being deleted and that still exist in our state
                                        // We can ignore these messages, but lets print a warning if a message refers to some unexpected property
                                        if (propertyName !== "willBeDeleted"){
                                            console.log('WARNING: property change for unexisting sound different from "willBeDeleted": ', propertyName, propertyValue);
                                        }
                                    }

                                } else if ((treeType === "SOURCE_STATE") || (treeType === "PRESET")){
                                    // If one of the main state or preset state properties changed, update main preset parameters as it will be contained in one of these
                                    updateMainPresetParameters();
                                } else if (treeType === "MIDI_CC_MAPPING"){
                                    updateMIDIMappingEditor(treeUUID);
                                }
                            }

                        } else if (updateType === 'addedChild'){
                            const parentTreeUUID = restOfDataSliced[0];
                            const parentTreeType = restOfDataSliced[1];
                            const indexInParentChildren = parseInt(restOfDataSliced[2], 10);
                            const childXmlString = restOfDataSliced.slice(3, restOfDataSliced.length).join(';');
                            // Add new child element to the state
                            var elementToUpdate;
                            if (parentTreeType === "PRESET"){
                                // If adding child of type preset, add it to the main SOURCE_STATE node regardless of the SOURCE_STATE uuid which some times changes
                                elementToUpdate = ss.state.childNodes[0];
                            } else {
                                elementToUpdate = self.state.querySelector("[uuid='" + parentTreeUUID + "']");
                            }
                            if (elementToUpdate !== null){
                                var nodeToAdd = self.parser.parseFromString(childXmlString, "text/xml").childNodes[0];
                                if (indexInParentChildren < 0){
                                    elementToUpdate.appendChild(nodeToAdd);
                                } else {
                                    var beforeNode = elementToUpdate.childNodes[indexInParentChildren];
                                    elementToUpdate.insertBefore(nodeToAdd, beforeNode);
                                }

                                // If new sounds or midi cc mappings are added, recreate sounds section
                                if ((nodeToAdd.tagName === "MIDI_CC_MAPPING") || (nodeToAdd.tagName === "SOUND")){
                                    updateSoundList();
                                }
                            }

                        } else if (updateType === 'removedChild'){
                            const childToRemoveUUID = restOfDataSliced[0];
                            const childToRemoveType = restOfDataSliced[1];

                            // Remove the selected element from the state
                            const stateElementToRemove = self.state.querySelector("[uuid='" + childToRemoveUUID + "']");
                            if (stateElementToRemove !== null){
                                stateElementToRemove.remove();

                                // Trigger corresponding UI updates
                                const domElementToUpdate = document.getElementById(childToRemoveUUID);
                                if (domElementToUpdate !== null){
                                    domElementToUpdate.remove();
                                }

                                if (childToRemoveType === "SOUND"){
                                    updateAllSoundCardNumbers();
                                }
                            }
                        }

                        self.scheduleExtraFullStateRequestAfterBurstOfMessages();
                    }
                };

                return socket;
            }

            sendMessageToPlugin(address, args){
                const message = address + ':' + args.join(';');
                this.wsConnection.send(message);
            }

            requestFullState(){
                this.sendMessageToPlugin('/get_state', ["full"]);
            }

            requestVolatileState(){
                this.sendMessageToPlugin('/get_state', ["volatile"]);
            }

            // Util methods to get state info

            getSounds(){
                return ss.state.getElementsByTagName('SOUND');
            }

            getSoundSamplerSounds(sound){  // sound = sound xml state
                if (sound !== null){
                    return sound.getElementsByTagName('SOUND_SAMPLE');
                } else {
                    return [];
                }

            }

            getFirstSoundSampleSound(sound) {  // sound = sound xml state
                return this.getSoundSamplerSounds(sound)[0];
            }

            getSoundFromSoundUUID(soundUUID){
                return ss.state.querySelector("[uuid='" + soundUUID + "']");
            }

            getSoundFromSoundSampleUUID(soundSampleUUID){
                const soundSample = ss.state.querySelector("[uuid='" + soundSampleUUID + "']");
                return ss.getSoundFromSoundUUID(soundSample.parentElement.getAttribute('uuid'));
            }

            getMidiMappingStateFromMappingUUID(mappingUUID){
                return ss.state.querySelector("[uuid='" + mappingUUID + "']");
            }

            getSoundMidiMappings(sound){  // sound = sound xml state
                return sound.getElementsByTagName('MIDI_CC_MAPPING');
            }

            findSoundIdxFromSoundUUID(soundUUID){
                var sounds = ss.getSounds();
                for (var i=0; i<sounds.length; i++) {
                    if (sounds[i].getAttribute("uuid") == soundUUID){
                        return i + 1;
                    }
                }
                return -1
            }

            findSoundIdxFromSourceSamplerSoundUUID(samplerSoundUUID){
                var sounds = ss.getSounds();
                for (var i=0; i<sounds.length; i++) {
                    var samplerSounds = this.getSoundSamplerSounds(sounds[i]);
                    for (var j=0; j<samplerSounds.length; j++) {
                        var samplerSound = samplerSounds[j];
                        if (samplerSound.getAttribute("uuid") == samplerSoundUUID){
                            return i + 1;
                        }
                    }
                }
                return -1
            }

            getTmpFilesLocation(){
                return this.state.getElementsByTagName('SOURCE_STATE')[0].getAttribute('tmpFilesLocation');
            }

            // Util methods to change things of the state

            setSoundParameter(parameterName, parameterVal, parameterMin, parameterMax){
                saveCurrentUserActionTime();
                this.sendMessageToPlugin('/set_sound_parameter', [selectedSoundUUID, parameterName, getProcessedSoundParameterValuLinToExp(parameterName,parameterVal, parameterMin, parameterMax)])
            }

            setSoundParameterInt(elementName, val){
                saveCurrentUserActionTime();
                this.sendMessageToPlugin('/set_sound_parameter_int', [selectedSoundUUID, elementName, val]);
                this.playSound();
            }

            getSoundParameterValue(soundUUID, soundParameterName){
                let sound = this.getSoundFromSoundUUID(soundUUID);
                let soundParameterVal = sound.getAttribute(soundParameterName);
                return soundParameterVal;
            }

            replaceAllSoundsByQuery(){
                var query = document.getElementsByName('query')[0].value;
                var numSounds = document.getElementsByName('numSounds')[0].value || 16;
                var minSoundLength = document.getElementsByName('minSoundLength')[0].value || 0.0;
                var maxSoundLength = document.getElementsByName('maxSoundLength')[0].value || 0.5;
                var noteMappingType = document.getElementsByName('noteMappingType')[0].value;
                this.sendMessageToPlugin('/replace_sounds_from_query', [query, numSounds, minSoundLength, maxSoundLength, noteMappingType])
            }

            replaceSoundByQuery(){
                var numSoundToReplace = document.getElementsByName('soundIdxToReplace')[0].value;
                var soundUUIDToReplace = ss.getSounds()[numSoundToReplace - 1].getAttribute('uuid');
                var query = document.getElementsByName('query')[0].value;
                var numSounds = document.getElementsByName('numSounds')[0].value || 16;
                var minSoundLength = document.getElementsByName('minSoundLength')[0].value || 0.0;
                var maxSoundLength = document.getElementsByName('maxSoundLength')[0].value || 0.5;
                var noteMappingType = document.getElementsByName('noteMappingType')[0].value;
                this.sendMessageToPlugin('/replace_sound_from_query', [soundUUIDToReplace, query, numSounds, minSoundLength, maxSoundLength, noteMappingType])
            }

            addSoundsByQuery(){
                var query = document.getElementsByName('query')[0].value;
                var numSounds = document.getElementsByName('numSounds')[0].value || 16;
                var minSoundLength = document.getElementsByName('minSoundLength')[0].value || 0.0;
                var maxSoundLength = document.getElementsByName('maxSoundLength')[0].value || 0.5;
                this.sendMessageToPlugin('/add_sounds_from_query', [query, numSounds, minSoundLength, maxSoundLength, "contiguous"])
            }

            reapplyLayout(){
                var noteMappingType = document.getElementsByName('noteMappingType')[0].value;
                this.sendMessageToPlugin('/reapply_layout', [noteMappingType]);
            }

            clearAllSounds(){
                this.sendMessageToPlugin('/clear_all_sounds', [])
            }

            setMidiInChannel() {
                var midiInChannel = document.getElementsByName('midiInChannel')[0].value;
                this.sendMessageToPlugin('/set_midi_in_channel', [midiInChannel])
            }

            setReverbParameters() {
                var reverbParameterList = Object.keys(reverbParams).map(function(key){
                    return reverbParams[key];
                })
                this.sendMessageToPlugin('/set_reverb_parameters', reverbParameterList)
            }

            setNumVoices() {
                var numVoices = document.getElementsByName('numVoices')[0].value;
                this.sendMessageToPlugin('/set_polyphony', [numVoices])
            }

            playSound(){

                //Add sound to the list to stop if a new sound is selected
                playStopSoundList.push(selectedSoundUUID);


                if (playStopSoundList.length > 1) {
                    //Stop the previous sound and remove it
                    ss.stopSound(playStopSoundList[0]);
                    playStopSoundList.shift();

                }

                this.sendMessageToPlugin('/play_sound', [selectedSoundUUID])


            }

            stopSound(soundUUID){
                this.sendMessageToPlugin('/stop_sound', [soundUUID])
            }

            removeSound(soundUUID){
                this.sendMessageToPlugin('/remove_sound', [soundUUID])
            }

            savePreset(){
                var name = document.getElementsByName('presetName')[0].value;
                var idx = document.getElementsByName('presetIdx')[0].value;
                this.sendMessageToPlugin('/save_preset', [name, idx])
            }

            loadPreset() {
                var idx = document.getElementsByName('presetIdx')[0].value;
                this.sendMessageToPlugin('/load_preset', [idx])
            }

            nextPreset(){
                var idx = document.getElementsByName('presetIdx')[0].value;
                if (idx == undefined){
                    idx = -1;
                } else {
                    idx = parseInt(idx, 10);
                    if (isNaN(idx)){
                        idx = -1;
                    }
                }
                this.sendMessageToPlugin('/load_preset', [idx + 1])
            }

            previousPreset(){
                var idx = document.getElementsByName('presetIdx')[0].value;
                if (idx == undefined){
                    idx = 1;
                } else {
                    idx = parseInt(idx, 10);

                    if (isNaN(idx)){
                        idx = 1;
                    }
                }
                if (idx < 1){
                    idx = 1; //Will become 0 when subtracted 1
                }
                this.sendMessageToPlugin('/load_preset', [idx - 1])
            }


            createUpdateMapping(soundUUID, mappingID){
                var ccNumber = document.getElementById(mappingID + '_mappingCCNumber').value;
                var name = document.getElementById(mappingID + '_mappingParameterName').value;
                var minRange = parseFloat(document.getElementById(mappingID + '_mappingMinRange').value, 10);
                var maxRange = parseFloat(document.getElementById(mappingID + '_mappingMaxRange').value, 10);
                this.sendMessageToPlugin('/add_or_update_cc_mapping', [soundUUID, mappingID, ccNumber, name, minRange, maxRange]);
                if (mappingID == ""){
                    // Remove this element from DOM because this one is only while creating a new mappping
                    document.getElementById('newMappingPlaceholder_' + soundUUID).innerHTML = "";
                }
            }

            removeMidiMapping(soundUUID, mappingID){
                if (mappingID != ""){
                    this.sendMessageToPlugin('/remove_cc_mapping', [soundUUID, mappingID]);
                    // No need to remove the element itself because it will be removed when updating state
                } else {
                    document.getElementById('newMappingPlaceholder_' + soundUUID).innerHTML = "";  // Remove new mapping palceholder as the mapping was not yet created
                }
            }

        }

        document.addEventListener("DOMContentLoaded", function () {

            // Main funciont: reads some configuration properties form the URL and starte the StateSynchronizer
            // Once the StateSyncronizer is started, it will start to receive updates when changes happen in
            // the plugin's state. These updates will triger renders of appropriate parts of the UI.



            const queryString = window.location.search;
            const urlParams = new URLSearchParams(queryString);

            // If hostname is passed as a parameter, use it for WS and HTTP communications
            // Otherwise set it to the hostname of the current location
            if (urlParams.get('hostname') !== null){
                hostname = urlParams.get('hostname');
            } else {
                if (location.hostname !== ""){
                    hostname = location.hostname;
                } else {
                    hostname = 'localhost';
                }
            }

            // Get websockets/http connection config parameters (or use defaults)
            if (urlParams.get('wsPort') !== null){
                wsPort = urlParams.get('wsPort');
            } else {
                wsPort = "8125";
            }
            if (urlParams.get('useWss') !== null){
                useWss = urlParams.get('useWss') == '1';
            } else {
                useWss = false;
            }
            if (urlParams.get('httpPort') !== null){
                httpPort = urlParams.get('httpPort');
            } else {
                httpPort = "8124";
            }
            useHttps = useWss;


            // Start state synchronizer
            ss = new StateSynchronizer(wsPort, useWss);

            //Initialize the ADSR Envelope
            drawAdsrEnvelope();


            });

        // Util methods

        function integerToRadius(){

        }

        function radiusToInteger() {
            
        }

        function updateGlobalSoundUUID(){
            //Update the global sound UUID
            selectedSoundUUID = $("select#sound-dropdown option").filter(':selected').data('uuid');

            //Draw the ADSR Envelope for the selected sound
            drawAdsrEnvelope();

            //Draw the waveform for the selected sound
            drawSoundWaveform();

            //Update the sliders with the new sound
            updateAllParameterElements();


        };

        function updateAllParameterElements(){
            var pitch = ss.getSoundParameterValue(selectedSoundUUID, 'pitch');
            $('#pitch').val(pitch);
            updateKnobElements();

        }

        function updateKnobElements(){

            //A workaround for filter/amplitude ADSR selection
            if ($('#attack') !== null){
                var iterateList = knobParameterNamesAmp;
            } else {
                var iterateList = knobParameterNamesFilter;
            }
            for (var i=0; i < iterateList.length;i++){
                var element = iterateList[i];
                var elementVal = ss.getSoundParameterValue(selectedSoundUUID, element);
                $('#'+element).val(elementVal).trigger('change');
            }
        }

        window.onload = function(){
            var rangeInput = document.getElementById('q-par');
            rangeInput.addEventListener('click',function() {
                const isInput = event.target.nodeName === 'INPUT';
                console.log(event.target.id);
                var rangeTextName = event.target.id;
                var rangeText = document.getElementById('range-text-'+rangeTextName);
                console.log('rangetext',rangeTextName);
                let newVal = event.target.value;
                
                rangeText.innerHTML = newVal; //Set range text equal to input position

            })
        }

        function switchColorModes(obj){
            if($(obj).is(':checked')){
            $('.container').css('background-color',"#1d5eb2");
            }else {
                $('.container').css('background-color',"#e0e0e0");
            }

        }

        function saveCurrentUserActionTime(){
            lastUIAction = (new Date()).getTime();
        }

        function msSinceLastUserAction(){
            return (new Date()).getTime() - lastUIAction;
        }

        function linToExp(x){
            return (Math.pow(x,expStrength));
        }

        function expToLin(x){
            return (Math.pow(x,1/expStrength));
        }

        function sliderShouldBehaveExponentially(sliderElement){
            var name = sliderElement.name;
            if (name != null){
                if ((name.toLowerCase().indexOf("attack") > -1) ||
                    (name.toLowerCase().indexOf("decay") > -1) ||
                    (name.toLowerCase().indexOf("release") > -1) ||
                    (name == "filterCutoff")
                ){
                    return true;
                }
            }

            return false;
        }

        function getProcessedSoundParameterValuLinToExp(parameterName, parameterVal, parameterMin, parameterMax){
            var value = parseFloat(parameterVal, 10);
            return value;
        }

        function getProcessedSoundParameterValueExpToLin(sliderElement, valueRaw){
            if (sliderShouldBehaveExponentially(sliderElement) == true){
                return expToLin(valueRaw/sliderElement.max)*sliderElement.max;
            } else {
                return valueRaw;
            }
        }

        function getMidiControllableParameterNames(){
            // --> Start auto-generated code B
            parameterNames = ["startPosition", "endPosition", "loopStartPosition", "loopEndPosition", "playheadPosition", "freezePlayheadSpeed", "filterCutoff", "filterRessonance", "gain", "pan", "pitch"]
            // --> End auto-generated code B
            return parameterNames;
        }

        function getAllSoundParameterNames(){
            // --> Start auto-generated code C
            parameterNames = ["launchMode", "startPosition", "endPosition", "loopStartPosition", "loopEndPosition", "loopXFadeNSamples", "reverse", "noteMappingMode", "numSlices", "playheadPosition", "freezePlayheadSpeed", "filterCutoff", "filterRessonance", "filterKeyboardTracking", "filterAttack", "filterDecay", "filterSustain", "filterRelease", "filterADSR2CutoffAmt", "gain", "attack", "decay", "sustain", "release", "pan", "pitch", "pitchBendRangeUp", "pitchBendRangeDown", "mod2CutoffAmt", "mod2GainAmt", "mod2PitchAmt", "mod2PlayheadPos", "vel2CutoffAmt", "vel2GainAmt", "midiChannel"]
            // --> End auto-generated code C
            return parameterNames;
        }

        function isSoundParameter(parameterName){
            return getAllSoundParameterNames().indexOf(parameterName) > -1;
        }

        function getAllSoundParameterTypes(){
            // --> Start auto-generated code D
            parameterTypes = ["int", "float", "float", "float", "float", "int", "int", "int", "int", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "int"]
            // --> End auto-generated code D
            return parameterTypes;
        }

        function getParameterType(parameterName){
            return getAllSoundParameterTypes()[getAllSoundParameterNames().indexOf(parameterName)];
        }

        // Methods to update different parts of the UI


        function addNewMIDIMappingEditor(soundUUID) {
                document.getElementById('newMappingPlaceholder_' + soundUUID).innerHTML = createMIDIMappingEditorFromRawParams(soundUUID, "", 0, "", 0.0, 1.0);
            }

        function createMIDIMappingEditor(soundUUID, mapping){ // mapping xml form state
            var mappingUUID = mapping.getAttribute('uuid');
            var ccNumber = parseInt(mapping.getAttribute('ccNumber'), 10);
            var name = mapping.getAttribute('parameterName');
            var minRange = parseFloat(mapping.getAttribute('minRange'), 10);
            var maxRange = parseFloat(mapping.getAttribute('maxRange'), 10);
            return createMIDIMappingEditorFromRawParams(soundUUID, mappingUUID, ccNumber, name, minRange, maxRange);
        }

        function createMIDIMappingEditorFromRawParams(soundUUID, mappingUUID, ccNumber, parameterName, minRange, maxRange){
            html = '<div id="' + mappingUUID + '" data-sound-id="' + soundUUID + '" class="midiMapping">';
            html += 'CC number: <input id="' + mappingUUID + '_mappingCCNumber" value="' + ccNumber + '" type="number"><br>';
            html += 'Parameter: <select class="select-css" id="' + mappingUUID + '_mappingParameterName">';
            var availableParams = getMidiControllableParameterNames();
            for (var i=0; i<availableParams.length; i++){
                if (availableParams[i] != parameterName){
                    html += '<option value="' + availableParams[i] + '">&nbsp;&nbsp;' + availableParams[i] + '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</option>';
                } else {
                    html += '<option value="' + availableParams[i] + '" selected>&nbsp;&nbsp;' + availableParams[i] + '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</option>';
                }
            }
            html += '</select><br>';
            html += '<input type="range" id="' + mappingUUID + '_mappingMinRange"  min="0" max="1.0" value="' + minRange + '" step="0.01"> min: <span id="' + mappingUUID + '_mappingMinRangeLabel"></span><br>';
            html += '<input type="range" id="' + mappingUUID + '_mappingMaxRange"  min="0" max="1.0" value="' + maxRange + '" step="0.01"> max: <span id="' + mappingUUID + '_mappingMaxRangeLabel"></span><br>';
            html += '<button onclick="ss.createUpdateMapping(\'' + soundUUID + '\',\'' + mappingUUID + '\')">save</button><button onclick="ss.removeMidiMapping(\'' + soundUUID + '\',\'' + mappingUUID + '\')">x</button>';
            html += '</div>';
            return html;
        }
        function updateSoundParameter(soundUUID, parameterName, parameterValue){
            const sliderElement = document.getElementById(soundUUID + '_' + parameterName);
            if (sliderElement === null){
                return;
            }
            if (parameterValue === undefined){
                var sound =  ss.getSoundFromSoundUUID(soundUUID);
                parameterValue = sound.getAttribute(parameterName);
            }
            const parameterType = getParameterType(parameterName);
            if (parameterType == "float"){
                sliderElement.value = getProcessedSoundParameterValueExpToLin(sliderElement, parseFloat(parameterValue, 10));
            } else if (parameterType == "int"){
                sliderElement.value = parseInt(parameterValue, 10);
            }
            updateSliderLabel(sliderElement);
        }

        function updateMIDIMappingEditor(mappingUUID){
            var mapping = ss.getMidiMappingStateFromMappingUUID(mappingUUID);
            var ccNumber = parseInt(mapping.getAttribute('ccNumber'), 10);
            var name = mapping.getAttribute('parameterName');
            var minRange = parseFloat(mapping.getAttribute('minRange'), 10);
            var maxRange = parseFloat(mapping.getAttribute('maxRange'), 10);

            document.getElementById(mappingUUID + '_mappingCCNumber').value = ccNumber;
            document.getElementById(mappingUUID + '_mappingParameterName').value = name;
            document.getElementById(mappingUUID + '_mappingMinRange').value = minRange;
            document.getElementById(mappingUUID + '_mappingMinRangeLabel').innerHTML = minRange;
            document.getElementById(mappingUUID + '_mappingMaxRange').value = maxRange;
            document.getElementById(mappingUUID + '_mappingMaxRangeLabel').innerHTML = maxRange;
        }

        function updateAllSoundCardNumbers() {
            var sounds = ss.getSounds();
            for (i=0; i<sounds.length; i++) {
                var soundUUID = sounds[i].getAttribute('uuid');
                var soundCard = document.getElementById(soundUUID + '_idx');
                if (soundCard !== null){
                    soundCard.innerHTML =  document.getElementById(soundUUID).dataset.soundIdx;
                }
            }
        }

       function changeADSRElementId(val){
           if (val.className == 'adsr-filter'){
               document.getElementsByClassName("adsr-filter")[0].style["fontWeight"] = "bold";
               document.getElementsByClassName("adsr-amplitude")[0].style["fontWeight"] = "normal";
               $('#attack').attr("id","filterAttack");
               $('#decay').attr("id","filterDecay");
               $('#sustain').attr("id","filterSustain");
               $('#release').attr("id", "filterRelease");
               $('#gain').attr("id","filterCutoff");
               $('#filterCutoff>p').text("Cutoff");
               $('#filterRessonance').css('visibility','visible');
               $('#pan').attr("id","filterADSR2CutoffAmt");
               $('#filterADSR2CutoffAmt>p').text("CutoffAmt");
           }else{
               document.getElementsByClassName("adsr-amplitude")[0].style["fontWeight"] = "bold";
               document.getElementsByClassName("adsr-filter")[0].style["fontWeight"] = "normal";
               $('#filterAttack').attr("id","attack");
               $('#filterDecay').attr("id","decay");
               $('#filterSustain').attr("id","sustain");
               $('#filterRelease').attr("id", "release");
               $('#filterCutoff').attr("id","gain");
               $('#gain>p').text('Gain');
               $('#filterRessonance').css('visibility','hidden');
               $('#filterADSR2CutoffAmt').attr("id","pan");
               $('#pan>p').text("Pan");
           }
       }

        var rateLimitedTimers = {};
        var lastTimeFunctionCalled = {};
        var maxUpdateSoundRate = 100;
        function triggerRateLimitedUpdateSoundCard(soundUUID){
            // Use this function to reduce the rate of the calls to updateSoundCard
            // It can happen that when many properties change, we call updateSoundCard many times. Using this function this will be reduced.
            if ((lastTimeFunctionCalled[soundUUID] === undefined) || (Date.now() - lastTimeFunctionCalled[soundUUID] > maxUpdateSoundRate)){
                lastTimeFunctionCalled[soundUUID] = Date.now();
            }

            if (rateLimitedTimers[soundUUID] !== undefined){
                // If a timer already set, cancel it
                clearTimeout(rateLimitedTimers[soundUUID]);
            }
            rateLimitedTimers[soundUUID] = setTimeout(() => {
                lastTimeFunctionCalled[soundUUID] = Date.now();
            }, maxUpdateSoundRate);
        }

        function updateSoundCard(soundUUID){  //sound = xml element from state
            var sound = ss.getSoundFromSoundUUID(soundUUID);
            if (sound === null){
                // Sound can be null if triggering this method in a delayed way and sound does not longer exist
                return;
            }
            var soundUUID = sound.getAttribute('uuid');
            var samplerSounds = ss.getSoundSamplerSounds(sound);
            var samplerSound = samplerSounds[0];
            var soundCard = document.getElementById(soundUUID);
            if (soundCard === null){
                // Also if soundCard has not yet been created, don't continue
                return;
            }
            var soundInfoElement = document.getElementById('soundCardInfo_' + soundUUID);
            var downloadProgress = 0.0;  // Calculate download progress, take into account the case in which a sound has multiple source sampler sounds
            for (var i=0; i<samplerSounds.length; i++){
                var downloadCompleted = samplerSounds[i].getAttribute('downloadCompleted');
                var progress = samplerSounds[i].getAttribute('downloadProgress');
                if ((downloadCompleted === null) || (progress === null)){
                    downloadProgress += 0;
                } else {
                    var progress;
                    if (samplerSounds[i].getAttribute('downloadCompleted') === '1'){
                        progress = 100.0;
                    } else {
                        progress = parseFloat(samplerSounds[i].getAttribute('downloadProgress'));
                    }
                    downloadProgress += progress;
                }
            }
            downloadProgress = downloadProgress/samplerSounds.length;

            var soundID = samplerSound.getAttribute('soundId');
            var sourceSamplerSoundUUID = samplerSound.getAttribute('uuid');
            var soundName = samplerSound.getAttribute('name');
            if (samplerSounds.length > 1){
                soundName = '(' + samplerSounds.length + ' sounds) ' + soundName;
            }
            var licenseURL = samplerSound.getAttribute('license') || "-";
            var soundIdx = 0;
            soundIdx = soundCard.dataset.soundIdx;

            if (sound.getAttribute("allSoundsLoaded") === "1"){
                // Sound already loaded, show all info (if it has not been already shown)
                html = '<div class="transportSoundButtons"><button onclick="ss.playSound(\'' + soundUUID + '\')">&#x25b6</button><button onclick="ss.stopSound(\'' + soundUUID + '\')">&#x25fc</button><button onclick="ss.removeSound(\'' + soundUUID + '\')">x</button></div>';
                html += '<h4><span id="' + soundUUID + '_idx">' + soundIdx + "</span> - " + soundID + '</h4>';
                html += '<div class="ellipsis">' + soundName + '</div>';
                var licenseName = "-";
                if ( licenseURL.indexOf('/by/') > -1) {licenseName = 'CC-BY'}
                else if ( licenseURL.indexOf('/sampling+/') > -1) {licenseName = 'S+'}
                else if ( licenseURL.indexOf('/by-nc/') > -1) {licenseName = 'CC-BY-NC'}
                else if ( licenseURL.indexOf('/zero/') > -1) {licenseName = 'CC0'}
                html += '<div class="ellipsis">' + parseFloat(samplerSound.getAttribute('duration'), 10).toFixed(2) + 's | ' + licenseName + '</div>';
                soundInfoElement.innerHTML = html;

                var soundControlsElement = document.getElementById('soundCardControls_' + soundUUID);
                if (soundControlsElement.style.display === "none") {
                    soundControlsElement.style.display = "block";
                }

                var soundMappingsWrapperElement = document.getElementById('soundCardMappingsWrapper_' + soundUUID);
                if (soundMappingsWrapperElement.style.display === "none") {
                    soundMappingsWrapperElement.style.display = "block";
                }

                drawSoundWaveform(sourceSamplerSoundUUID, 'soundCardWaveform_' + soundUUID, 'waveformLoadingIndicator_' + soundUUID);
            } else {
                // Sound not yet loaded, show download progress
                html = '<h4><span id="' + soundUUID + '_idx">' + soundIdx + " - " + soundID + '</h4>';
                html += '<div class="ellipsis">' + soundName + '</div>';
                if (downloadProgress === 100.0){
                    html += '<div>Loading in sampler...</div>';
                } else if (downloadProgress >= 0.0) {
                    html += '<div style="background: linear-gradient(to right, #4eb8a4 ' + downloadProgress + '%, black ' + downloadProgress + '%);">&nbsp;Downloading: ' + parseFloat(downloadProgress).toFixed(2) + '% </div>';
                }
                soundInfoElement.innerHTML = html;
            }
        }


        function updateMainPresetParameters(){
            var sourceState = ss.state.getElementsByTagName('SOURCE_STATE')[0];
            document.getElementsByName('presetIdx')[0].value = sourceState.getAttribute('currentPresetIndex');
            document.getElementsByName('midiInChannel')[0].value = sourceState.getAttribute('globalMidiInChannel');

            var presetState = sourceState.getElementsByTagName('PRESET')[0];
            document.getElementsByName('presetName')[0].value = presetState.getAttribute('name');
            document.getElementsByName('numVoices')[0].value = presetState.getAttribute('numVoices');

        }

        function updateLaunchMode(obj) {
            var currentMode = $("#outer-box-launch > #inner-box-launch > p").text();
            var currentModeIndex = launchModes.indexOf(currentMode.toLowerCase());
            var nextModeIndex = currentModeIndex;

            //Get the direction of arrow
            var direction = obj.className;
            if (direction == 'left-arrow-inner'){
                nextModeIndex = currentModeIndex - 1;
                if (nextModeIndex < 0) {
                    nextModeIndex = 3;
                }

            }else{
                nextModeIndex = currentModeIndex + 1;
                if (nextModeIndex == 4) {
                    nextModeIndex = 0;
                }
            }

            var newText = launchModes[nextModeIndex];
            $("#outer-box-launch > #inner-box-launch > p").text(newText);
            ss.setSoundParameterInt('launchMode', nextModeIndex);

        }

        function updateSoundList(soundUUID){
            var sound = ss.getSoundFromSoundUUID(soundUUID);

            if (sound === null){
                // Sound can be null if triggering this method in a delayed way and sound does not longer exist
                return;
            }
            //Wait until the query is done
            var samplerSounds = ss.getSoundSamplerSounds(sound);
            var samplerSound = samplerSounds[0];
            //If sound exists and loaded, don't add id
                    $("div.sound-list select").append($('<option>')
                        .text(samplerSound.getAttribute('name'))
                        .data({
                            uuid: soundUUID,
                            sound: samplerSound.getAttribute('name'),
                        })
                        );
        }



        function updateFullUI(){
            // Set the main preset parameters to the values form the state
            updateMainPresetParameters();
            // Update all the section with individual sound cards
        }

        function updateVolatileUI(){
            // Update the audio meters and the voice allocation section
            // Also update other things like query status


            //Launch Mode Check
            checkBox = document.getElementById('loopfb');

            var VolatileState = ss.volatileState.getElementsByTagName('VOLATILE_STATE')[0];

            var isQuerying = VolatileState.getAttribute('isQuerying') != "0";


            var voicesStateElement = document.getElementById('voicesState');
            var html = '<div class="voices">';
            if (VolatileState !== undefined){
                var voiceActivations = VolatileState.getAttribute('voiceActivations').split(',').slice(0, -1);
                var voiceSoundIdxs = VolatileState.getAttribute('voiceSoundIdxs').split(',').slice(0, -1);
                var voiceSoundPlayPosition = VolatileState.getAttribute('voiceSoundPlayPosition').split(',').slice(0, -1);

                for (var i=0; i<voiceSoundIdxs.length; i++){
                    if (voiceSoundIdxs[i] == "-1"){
                        // Draw empty square
                        html += '<div class="voice"><div class="voice_progress" style="width:0%;">&nbsp;</div></div>'
                    } else {
                        html += '<div class="voice"><div class="voice_progress" style="width:' + 100 * parseFloat(voiceSoundPlayPosition[i], 10) + '%;">' + ss.findSoundIdxFromSourceSamplerSoundUUID(voiceSoundIdxs[i]) + '</div></div>'
                    }
                }
            }
            html += "</div>";
            voicesStateElement.innerHTML = html;

            var metersStateElement = document.getElementById('metersState');
            var html = '<div class="meters">';
            if (VolatileState !== undefined){
                var audioLevels = VolatileState.getAttribute('audioLevels').split(',').slice(0, -1);
                for (var i=0; i<audioLevels.length; i++){
                    html += '<div class="channel_meter"><div class="channel_level" style="height:' + 100 * parseFloat(audioLevels[i], 10) + '%;"></div></div>'
                }
            }
            html += "</div>";
            metersStateElement.innerHTML = html;
        }

       function drawSoundWaveform(){
            console.log("draw",selectedSoundUUID);
            var sound = ss.getSoundFromSoundUUID(selectedSoundUUID);
            var samplerSound = ss.getSoundSamplerSounds(sound);
            var sourceSamplerSoundUUID = samplerSound[0].getAttribute('uuid');


            const canvas = document.getElementById("waveform");
            if (canvas !== null){
                    if (httpPort !== undefined){
                        let url = 'http' + (useHttps ? 's':'') + '://' + hostname + ':' + httpPort + '/sounds_data/' + sourceSamplerSoundUUID + '.wav';
                        //let url = ss.getTmpFilesLocation() + '/' + sourceSamplerSoundUUID + '.wav'; // Not supported because of CORS...
                        console.log("Getting waveform for", url);

                        //Remove the previous sounds wave element
                        $('wave').remove();
                        var wavesurfer = WaveSurfer.create({
                                                    container: document.querySelector('#waveform'),
                                                    waveColor: 'purple',
                                                    progressColor: 'aqua',
                                                    backend: 'MediaElement',
                                                    cursorWidth: 2,
                                                    responsive: 'true',
                                                    height: '100',
                                                    plugins: [
                                                        WaveSurfer.regions.create({ 
                                                            regionsMinLength: 0.01,
                                                            regions: [
                                                            {
                                                                loop: true,
                                                                color: 'hsla(400, 100%, 30%, 0.9)',
                                                                maxLength: 2,
                                                            },
                                                        ],
                                                        dragSelection: {
                                                            slop: 1
                                                        }
                                                        })
                                                    ]

                                        });

                        // Limit the region element to 1
                        wavesurfer.on('region-created', region => {  
                                wavesurfer.regions.clear();
                            });
                        wavesurfer.load(url);

                        wavesurfer.on('region-updated', region =>{
                            var launchMode = $('#outer-box-launch > #inner-box-launch p').text();
                            if (launchMode == 'loop' || launchMode == 'loopfb'){
                                //Get the duration of the sound
                                var soundLength = wavesurfer.backend.getDuration();
                                

                                //Stop the previous sound
                                ss.stopSound();

                                //Set the start and end of the looped sound
                                ss.setSoundParameter('loopStartPosition', region.start/soundLength,0,1);
                                ss.setSoundParameter('loopEndPosition', region.end/soundLength,0,1);
                            }

                        })

                    }
                }
            }



        function drawAdsrEnvelope(){

        var DefaultParamsMod = {
            attackTime: ss.getSoundParameterValue(selectedSoundUUID, 'filterAttack'),
            decayTime: ss.getSoundParameterValue(selectedSoundUUID, 'filterDecay'),
            sustainLevel: ss.getSoundParameterValue(selectedSoundUUID, 'filterSustain'),
            releaseTime: ss.getSoundParameterValue(selectedSoundUUID, 'filterRelease'),
            gateTime: 1,
            peakLevel: 1,
            epsilon: 0.001,
            attackCurve: "exp",
            decayCurve: "exp",
            releaseCurve: "exp",
            };

        var DefaultParamsAmp = {
            attackTime: ss.getSoundParameterValue(selectedSoundUUID, 'attack'),
            decayTime: ss.getSoundParameterValue(selectedSoundUUID, 'decay'),
            sustainLevel: ss.getSoundParameterValue(selectedSoundUUID, 'sustain'),
            releaseTime: ss.getSoundParameterValue(selectedSoundUUID, 'release'),
            gateTime: 1,
            peakLevel: 1,
            epsilon: 0.001,
            attackCurve: "exp",
            decayCurve: "exp",
            releaseCurve: "exp",
            };

            //If the page has just loaded, operate on default parameter values
            startTime = -1;

            var env = new ADSREnvelope(DefaultParamsMod);
            var ampEnv = new ADSREnvelope(DefaultParamsAmp);


            var canvas = document.getElementById("adsr-envelope");
            var context = canvas.getContext("2d");

            var contextAmp = canvas.getContext("2d");
            var x, i;

            duration = (((env.duration / 5)|0) + 1) * 5;

            context.fillStyle = "#f2f1f1";
            context.fillRect(0, 0, canvas.width, canvas.height);

            context.strokeStyle = "#000000";
            context.lineWidth = 0.0101;

            for (i = 1; i < duration; i++) {
                x = (((i / duration) * canvas.width)|0) + 0.5;

                context.beginPath();
                context.moveTo(x, 0);
                context.lineTo(x, canvas.height);
                context.stroke();
            }

            contextAmp.strokeStyle = "rgb(80, 1, 80)";
            contextAmp.lineWidth = 1;

            for (i = 1; i < duration; i++) {
                x = (((i / duration) * canvas.width)|0) + 0.5;

                contextAmp.beginPath();
                contextAmp.moveTo(x, 0);
                contextAmp.lineTo(x, canvas.height);
                contextAmp.stroke();
            }

            //Draw two envelopes for modulation and amplitude
            drawByEnvelope(contextAmp, duration, ampEnv,2,"linear-gradient(to right top, #8222ac, #d23177, #e1765b, #d6b274, #d1e0b7)", 'amp');
            drawByEnvelope(context, duration, env,2, "rgba(22, 160, 133, 0.8)", 'modulation');


            function drawByEnvelope(context, duration, env, lineWidth, strokeStyle, type) {
            var t, v, y, x;
            var i, imax;
            var canvas = document.getElementById("adsr-envelope");


            context.strokeStyle = strokeStyle;
            context.lineWidth = lineWidth;
            context.lineCap = "round";

            context.beginPath();
            for (i = 0, imax = canvas.width; i < imax; i++) {
                t = (i / imax) * duration;
                v = env.valueAt(t);
                y = canvas.height - (canvas.height * v);
                x = (i / imax) * canvas.width;

                context.lineTo(x, y);
            }
            context.stroke();

            }}

          


    </script>
</head>

<body>

    <div class="container">
        <div class="source-icon">SOURCE</div>
        <div class="freesound">
            <p>A freesound community sampler</p>
        </div>
        <div class="query-parameters">
            <div class="query-search">
                <input name="query" value="" type="search" placeholder="piano" class="query-text" />
                <div class="query-button"  onclick="ss.addSoundsByQuery()">
                    <li class="bar first"></li>
                    <li class="bar second"></li>
                    <li class="bar third"></li>
                    <li class="bar fourth"></li>
                    <li class="bar fifth"></li>
                    <li class="bar sixth"></li>
                    <li class="bar last"></li>
                </div>
            </div>
            <div id="q-par">
                <div class="slider-regular">
                    <input  id="numSounds" name="numSounds" type="range" min="1" max="60" value="1" step="1" placeholder="Number of Sounds"/>
                    <div class="range-text" id="range-text-numSounds">1</div>
                </div>
                    <div class="slider-regular">
                    <input id="minSoundLength" name="minSoundLength" type="range" min="1" max="100" value="1" step="1" placeholder="Minimum Sound Length"/>
                    <div class="range-text" id="range-text-minSoundLength">1</div>
                </div>
                <div class="slider-regular">
                    <input id="maxSoundLength" name="maxSoundLength" type="range" min="1" max="100" value="1" step="1" placeholder="Minimum Sound Length"/>
                    <div class="range-text" id="range-text-maxSoundLength">1</div>
                </div>
                <div class="slider-regular">
                    Continuous
                </div>
            </div>
        </div>
        <div class="waveform">
            <div id="waveform"></div>
            <div class="launch-mode">
                <div class="left-arrow">
                    <button class="left-arrow-inner" onclick="updateLaunchMode(this);"></button>
                </div>
                <div class="outer-box" id="outer-box-launch">
                    <div class="inner-box" id="inner-box-launch">
                        <p>gate</p>
                    </div>
                </div>
                <div class="right-arrow">
                    <button class="right-arrow-inner" onclick="updateLaunchMode(this);"></button>
                </div>
        </div>
        </div>
        <div class="adsr">
            <canvas id="adsr-envelope" style="background-color: antiquewhite;"></canvas>
        </div>
        <div class="adsr-envelope-knobs">
            <div class="adsr-filter" onclick="changeADSRElementId(this);">
                <p>Filter</p>
            </div>
            <div class="adsr-amplitude" onclick="changeADSRElementId(this);">
                <p>Amplitude</p>
            </div>
            <div class="adsr-first-knob">
            <div class="knob-1" id="attack">
                <div class="knob-inner">
                </div>
                <p>attack</p>
            </div>
            <div class="knob-1" id="decay">
                <div class="knob-inner"></div>
                <p>decay</p>
            </div>
            <div class="knob-1" id="sustain">
                <div class="knob-inner"></div>
                <p>sustain</p>
            </div>
            <div class="knob-1" id="release">
                <div class="knob-inner"></div>
                <p>release</p>
            </div>
        </div>
        <div class="adsr-second-knob">
            <div class="knob-2000" id="filterCutoff">
                <div class="knob-inner"></div>
                <p>Cutoff</p>
            </div>
            <div class="knob-1" id="filterRessonance">
                <div class="knob-inner"></div>
                <p>Ressonance</p>
            </div>
            <div class="knob-100" id="filterADSR2CutoffAmt">
                <div class="knob-inner"></div>
                <p>Cutoff Amount</p>
            </div>
        </div>

        </div>
        <div class="sound-list">
            <select multiple name="sounds" id="sound-dropdown" onclick="ss.playSound()" onchange="updateGlobalSoundUUID();">
            </select>
        </div>
        <div class="parameter-knobs">
            <div class="reverb-header">
                <p>Reverb</p>
            </div>
            <div class="reverb-knob-area">
                <div class="knob-reverb" id="roomSize">
                    <div class="knob-inner"></div>
                    <p>Room Size</p>
                </div>
                <div class="knob-reverb" id="damping">
                    <div class="knob-inner"></div>
                    <p>damping</p>
                </div>
                <div class="knob-reverb" id="wetLevel">
                    <div class="knob-inner"></div>
                    <p>Wet Level</p>
                </div>
                <div class="knob-reverb" id="dryLevel">
                    <div class="knob-inner"></div>
                    <p>Dry Level</p>
                </div>
            </div>
            <div class="modulation-header">
                <p>Modulation</p>
            </div>
            <div class="modulation-knob-area">
                <div class="knob-12" id="mod2GainAmt">
                    <div class="knob-inner"></div>
                    <p>Gain Amount</p>
                </div>
                <div class="knob-100" id="mod2CutoffAmt">
                    <div class="knob-inner"></div>
                    <p>Cutoff Amount</p>
                </div>
                <div class="knob-12" id="mod2PitchAmt">
                    <div class="knob-inner"></div>
                    <p>Pitch Amount</p>
                </div>
            </div>
            <div class="velocity-header">
                <p>Velocity</p>   
            </div>
            <div class="velocity-knob-area">
                <div class="knob-100" id="vel2CutoffAmt">
                    <div class="knob-inner"></div>
                    <p>Cutoff Amount</p>
                </div>
                <div class="knob-1" id="vel2GainAmt">
                    <div class="knob-inner"></div>
                    <p>Gain Amount</p>
                </div>
            </div>
        </div>
            <ul id="keyboard">
                <li note="C" class="white-key"></li>
                <li note="C#" class="black-key"></li>
                <li note="D" class="white-key offset"></li>
                <li note="D#" class="black-key"></li>
                <li note="E" class="white-key offset"></li>
                <li note="F" class="white-key"></li>
                <li note="F#" class="black-key"></li>
                <li note="G" class="white-key offset"></li>
                <li note="G#" class="black-key"></li>
                <li note="A" class="white-key offset"></li>
                <li note="A#" class="black-key"></li>
                <li note="B" class="white-key offset"></li>
                <li note="C2" class="white-key"></li>
                <li note="C#2" class="black-key"></li>
                <li note="D2" class="white-key offset"></li>
                <li note="D#2" class="black-key"></li>
                <li note="E2" class="white-key offset"></li>
                <li note="C" class="white-key"></li>
                <li note="C#" class="black-key"></li>
                <li note="D" class="white-key offset"></li>
                <li note="D#" class="black-key"></li>
                <li note="E" class="white-key offset"></li>

            </ul>
            <div class="pitch-section">
              <input class="slider-regular" style="transform: rotate(-90deg);width: 100px;" id ="pitch" type="range" name="pitch" min="-36.0" max="36.0" value="0.0" step="0.01" oninput="ss.setSoundParameter(this.name, this.value, this.min, this.max)"> Pitch: <span id="' + soundUUID + '_pitchLabel"></span><br>
            </div>
            <div class="controls_card controls_card_top" hidden>
                <h4>Preset & settings</h4>
                Preset number:</label><input name="presetIdx" value="" type="number">
                <button onclick="ss.savePreset()">Save</button>
                <button onclick="ss.loadPreset()">Load</button><br>
                Preset name:</label><input name="presetName" value="" type="text">
                <button onclick="ss.previousPreset()">&#x25C0</button><button onclick="ss.nextPreset()">&#x25b6</button><br>
                MIDI in channel:<input name="midiInChannel" value="" type="number" onchange="ss.setMidiInChannel()"><br>
                Num voices:<input name="numVoices" value="" type="number" onchange="ss.setNumVoices()"><br>
                <div id="voicesState"></div>
            </div>
            <div class="controls_card controls_card_top" hidden>
                <div id="metersState"></div>
            </div>

        </div>
    </div>
</body>
</html>
